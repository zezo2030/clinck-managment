# ğŸ“Š Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø®Ø§Ù…Ø³Ø©: Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª ÙˆØ§Ù„ØªÙ‚Ø§Ø±ÙŠØ± - Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¹ÙŠØ§Ø¯Ø§Øª

## ğŸ“‹ Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø®Ø§Ù…Ø³Ø©

Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø© ØªØ±ÙƒØ² Ø¹Ù„Ù‰ ØªØ·ÙˆÙŠØ± Ù†Ø¸Ø§Ù… ØªØ­Ù„ÙŠÙ„Ø§Øª Ø´Ø§Ù…Ù„ Ù…Ø¹ ØªÙ‚Ø§Ø±ÙŠØ± Ù…ØªÙ‚Ø¯Ù…Ø© ÙˆÙ„ÙˆØ­Ø§Øª ØªØ­ÙƒÙ… ØªÙØ§Ø¹Ù„ÙŠØ©.

**Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ù…Ù‚Ø¯Ø±Ø©:** 4 Ø£Ø³Ø§Ø¨ÙŠØ¹  
**Ø§Ù„Ù‡Ø¯Ù:** ØªØ·ÙˆÙŠØ± Ù†Ø¸Ø§Ù… ØªØ­Ù„ÙŠÙ„Ø§Øª Ù…ØªÙƒØ§Ù…Ù„ Ù…Ø¹ ØªÙ‚Ø§Ø±ÙŠØ± Ø°ÙƒÙŠØ©

---

## ğŸ› ï¸ Ø§Ù„ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©

### **Core Framework:**
- **NestJS** - Ø¥Ø·Ø§Ø± Ø¹Ù…Ù„ Node.js Ù…ØªÙ‚Ø¯Ù…
- **TypeScript** - Ù„ØºØ© Ø§Ù„Ø¨Ø±Ù…Ø¬Ø©
- **Node.js** - Ø¨ÙŠØ¦Ø© Ø§Ù„ØªØ´ØºÙŠÙ„

### **Database:**
- **PostgreSQL** - Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
- **Prisma** - ORM Ù„Ø¥Ø¯Ø§Ø±Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
- **Redis** - ØªØ®Ø²ÙŠÙ† Ù…Ø¤Ù‚Øª Ù„Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª

### **Analytics & Reporting:**
- **Chart.js** - Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠØ©
- **D3.js** - Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠØ© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
- **Puppeteer** - ØªÙˆÙ„ÙŠØ¯ PDFs

### **Data Processing:**
- **Bull Queue** - Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
- **Cron Jobs** - Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ± Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„Ø©

---

## ğŸ—ï¸ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ù„Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø®Ø§Ù…Ø³Ø©

```
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ modules/
â”‚   â”‚   â”œâ”€â”€ analytics/         # ÙˆØ­Ø¯Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª
â”‚   â”‚   â”‚   â”œâ”€â”€ analytics.controller.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ analytics.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ analytics.module.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ analytics-query.dto.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ report-request.dto.ts
â”‚   â”‚   â”‚   â””â”€â”€ entities/
â”‚   â”‚   â”‚       â””â”€â”€ analytics.entity.ts
â”‚   â”‚   â”œâ”€â”€ reports/           # ÙˆØ­Ø¯Ø© Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±
â”‚   â”‚   â”‚   â”œâ”€â”€ reports.controller.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ reports.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ reports.module.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â””â”€â”€ templates/
â”‚   â”‚   â”‚       â”œâ”€â”€ appointment-report.template.ts
â”‚   â”‚   â”‚       â”œâ”€â”€ financial-report.template.ts
â”‚   â”‚   â”‚       â””â”€â”€ doctor-report.template.ts
â”‚   â”‚   â”œâ”€â”€ dashboard/         # ÙˆØ­Ø¯Ø© Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…
â”‚   â”‚   â”‚   â”œâ”€â”€ dashboard.controller.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ dashboard.service.ts
â”‚   â”‚   â”‚   â””â”€â”€ dashboard.module.ts
â”‚   â”‚   â””â”€â”€ export/           # ÙˆØ­Ø¯Ø© Ø§Ù„ØªØµØ¯ÙŠØ±
â”‚   â”‚       â”œâ”€â”€ export.controller.ts
â”‚   â”‚       â”œâ”€â”€ export.service.ts
â”‚   â”‚       â””â”€â”€ export.module.ts
â”‚   â”œâ”€â”€ common/
â”‚   â”‚   â”œâ”€â”€ schedulers/        # Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„Ø©
â”‚   â”‚   â”‚   â”œâ”€â”€ analytics.scheduler.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ reports.scheduler.ts
â”‚   â”‚   â”‚   â””â”€â”€ data-cleanup.scheduler.ts
â”‚   â”‚   â”œâ”€â”€ queues/            # Ø·ÙˆØ§Ø¨ÙŠØ± Ø§Ù„Ù…Ù‡Ø§Ù…
â”‚   â”‚   â”‚   â”œâ”€â”€ analytics.queue.ts
â”‚   â”‚   â”‚   â””â”€â”€ reports.queue.ts
â”‚   â”‚   â””â”€â”€ utils/
â”‚   â”‚       â”œâ”€â”€ chart.util.ts
â”‚   â”‚       â”œâ”€â”€ pdf.util.ts
â”‚   â”‚       â””â”€â”€ data.util.ts
â”‚   â””â”€â”€ config/
â”‚       â”œâ”€â”€ analytics.config.ts
â”‚       â””â”€â”€ reports.config.ts
```

---

## ğŸ—„ï¸ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª - Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø®Ø§Ù…Ø³Ø©

### **Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©**

```prisma
// Ø¬Ø¯ÙˆÙ„ Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø®Ø²Ù†Ø©
model AnalyticsCache {
  id          Int      @id @default(autoincrement())
  type        String   // 'doctor_stats', 'clinic_stats', 'revenue_stats'
  entityId    Int?     // ID of doctor, clinic, etc.
  period      String   // 'daily', 'weekly', 'monthly', 'yearly'
  data        Json     // Cached analytics data
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([type, entityId, period])
  @@map("analytics_cache")
}

// Ø¬Ø¯ÙˆÙ„ Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±
model Report {
  id          Int      @id @default(autoincrement())
  name        String
  type        ReportType
  parameters  Json     // Report parameters
  status      ReportStatus @default(PENDING)
  fileUrl     String?
  generatedBy Int
  createdAt   DateTime @default(now())
  completedAt DateTime?

  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  user User @relation(fields: [generatedBy], references: [id])

  @@map("reports")
}

// Ø¬Ø¯ÙˆÙ„ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…
model DashboardSettings {
  id          Int      @id @default(autoincrement())
  userId      Int      @unique
  widgets     Json     // Dashboard widget configuration
  layout      Json     // Dashboard layout
  filters     Json     // Default filters
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  user User @relation(fields: [userId], references: [id])

  @@map("dashboard_settings")
}

// Enums
enum ReportType {
  APPOINTMENT
  FINANCIAL
  DOCTOR_PERFORMANCE
  PATIENT_ANALYSIS
  REVENUE
  CUSTOM
}

enum ReportStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}
```

---

## ğŸš€ Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªÙ†ÙÙŠØ°

### **Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø£ÙˆÙ„: ÙˆØ­Ø¯Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª**

#### **1.1 Ø®Ø¯Ù…Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©**
```typescript
// src/modules/analytics/analytics.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../database/prisma.service';
import { AnalyticsQueryDto } from './dto/analytics-query.dto';

@Injectable()
export class AnalyticsService {
  constructor(private prisma: PrismaService) {}

  async getDoctorStats(doctorId: number, startDate: Date, endDate: Date) {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ø§Ù„ÙƒØ§Ø´
    const cachedData = await this.getCachedAnalytics('doctor_stats', doctorId, startDate, endDate);
    if (cachedData) {
      return cachedData;
    }

    const appointments = await this.prisma.appointment.findMany({
      where: {
        doctorId,
        appointmentDate: {
          gte: startDate,
          lte: endDate,
        },
      },
    });

    const consultations = await this.prisma.consultation.findMany({
      where: {
        appointment: {
          doctorId,
          appointmentDate: {
            gte: startDate,
            lte: endDate,
          },
        },
      },
    });

    const ratings = await this.prisma.rating.findMany({
      where: {
        doctorId,
        createdAt: {
          gte: startDate,
          lte: endDate,
        },
      },
    });

    const totalAppointments = appointments.length;
    const completedAppointments = appointments.filter(a => a.status === 'COMPLETED').length;
    const cancelledAppointments = appointments.filter(a => a.status === 'CANCELLED').length;
    const noShowAppointments = appointments.filter(a => a.status === 'NO_SHOW').length;

    const totalConsultations = consultations.length;
    const completedConsultations = consultations.filter(c => c.status === 'COMPLETED').length;
    const totalDuration = consultations.reduce((sum, c) => sum + (c.duration || 0), 0);

    const averageRating = ratings.length > 0 
      ? ratings.reduce((sum, r) => sum + r.rating, 0) / ratings.length 
      : 0;

    const stats = {
      totalAppointments,
      completedAppointments,
      cancelledAppointments,
      noShowAppointments,
      completionRate: totalAppointments > 0 ? (completedAppointments / totalAppointments) * 100 : 0,
      totalConsultations,
      completedConsultations,
      totalDuration,
      averageRating: Math.round(averageRating * 10) / 10,
      totalRatings: ratings.length,
    };

    // Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ø§Ù„ÙƒØ§Ø´
    await this.cacheAnalytics('doctor_stats', doctorId, startDate, endDate, stats);

    return stats;
  }

  async getClinicStats(clinicId: number, startDate: Date, endDate: Date) {
    const cachedData = await this.getCachedAnalytics('clinic_stats', clinicId, startDate, endDate);
    if (cachedData) {
      return cachedData;
    }

    const appointments = await this.prisma.appointment.findMany({
      where: {
        clinicId,
        appointmentDate: {
          gte: startDate,
          lte: endDate,
        },
      },
      include: {
        payment: true,
      },
    });

    const doctors = await this.prisma.doctor.findMany({
      where: { clinicId },
    });

    const totalAppointments = appointments.length;
    const totalRevenue = appointments
      .filter(a => a.payment?.status === 'COMPLETED')
      .reduce((sum, a) => sum + Number(a.payment?.amount || 0), 0);

    const departmentStats = await this.prisma.department.findMany({
      where: { clinicId },
      include: {
        appointments: {
          where: {
            appointmentDate: {
              gte: startDate,
              lte: endDate,
            },
          },
        },
      },
    });

    const stats = {
      totalAppointments,
      totalRevenue,
      totalDoctors: doctors.length,
      departmentStats: departmentStats.map(dept => ({
        name: dept.name,
        appointments: dept.appointments.length,
      })),
    };

    await this.cacheAnalytics('clinic_stats', clinicId, startDate, endDate, stats);
    return stats;
  }

  async getPatientStats(patientId: number, startDate: Date, endDate: Date) {
    const appointments = await this.prisma.appointment.findMany({
      where: {
        patientId,
        appointmentDate: {
          gte: startDate,
          lte: endDate,
        },
      },
      include: {
        doctor: {
          include: { profile: true },
        },
        department: true,
      },
    });

    const consultations = await this.prisma.consultation.findMany({
      where: {
        appointment: {
          patientId,
          appointmentDate: {
            gte: startDate,
            lte: endDate,
          },
        },
      },
    });

    return {
      totalAppointments: appointments.length,
      completedAppointments: appointments.filter(a => a.status === 'COMPLETED').length,
      totalConsultations: consultations.length,
      completedConsultations: consultations.filter(c => c.status === 'COMPLETED').length,
      favoriteDoctors: this.getFavoriteDoctors(appointments),
      favoriteDepartments: this.getFavoriteDepartments(appointments),
    };
  }

  async getRevenueAnalytics(startDate: Date, endDate: Date) {
    const payments = await this.prisma.payment.findMany({
      where: {
        createdAt: {
          gte: startDate,
          lte: endDate,
        },
      },
      include: {
        appointment: {
          include: {
            doctor: {
              include: { profile: true },
            },
            clinic: true,
          },
        },
      },
    });

    const dailyRevenue = this.calculateDailyRevenue(payments);
    const monthlyRevenue = this.calculateMonthlyRevenue(payments);
    const paymentMethodStats = this.calculatePaymentMethodStats(payments);

    return {
      totalRevenue: payments
        .filter(p => p.status === 'COMPLETED')
        .reduce((sum, p) => sum + Number(p.amount), 0),
      totalRefunds: payments
        .filter(p => p.status === 'REFUNDED')
        .reduce((sum, p) => sum + Number(p.refundAmount || 0), 0),
      dailyRevenue,
      monthlyRevenue,
      paymentMethodStats,
    };
  }

  private getFavoriteDoctors(appointments: any[]) {
    const doctorCounts = appointments.reduce((acc, appointment) => {
      const doctorName = `${appointment.doctor.profile.firstName} ${appointment.doctor.profile.lastName}`;
      acc[doctorName] = (acc[doctorName] || 0) + 1;
      return acc;
    }, {});

    return Object.entries(doctorCounts)
      .sort(([,a], [,b]) => (b as number) - (a as number))
      .slice(0, 5);
  }

  private getFavoriteDepartments(appointments: any[]) {
    const departmentCounts = appointments.reduce((acc, appointment) => {
      const deptName = appointment.department.name;
      acc[deptName] = (acc[deptName] || 0) + 1;
      return acc;
    }, {});

    return Object.entries(departmentCounts)
      .sort(([,a], [,b]) => (b as number) - (a as number))
      .slice(0, 5);
  }

  private calculateDailyRevenue(payments: any[]) {
    const dailyRevenue = {};
    payments
      .filter(p => p.status === 'COMPLETED')
      .forEach(payment => {
        const date = payment.createdAt.toISOString().split('T')[0];
        dailyRevenue[date] = (dailyRevenue[date] || 0) + Number(payment.amount);
      });
    return dailyRevenue;
  }

  private calculateMonthlyRevenue(payments: any[]) {
    const monthlyRevenue = {};
    payments
      .filter(p => p.status === 'COMPLETED')
      .forEach(payment => {
        const month = payment.createdAt.toISOString().substring(0, 7);
        monthlyRevenue[month] = (monthlyRevenue[month] || 0) + Number(payment.amount);
      });
    return monthlyRevenue;
  }

  private calculatePaymentMethodStats(payments: any[]) {
    const methodStats = {};
    payments
      .filter(p => p.status === 'COMPLETED')
      .forEach(payment => {
        const method = payment.paymentMethod;
        if (!methodStats[method]) {
          methodStats[method] = { count: 0, total: 0 };
        }
        methodStats[method].count++;
        methodStats[method].total += Number(payment.amount);
      });
    return methodStats;
  }

  private async getCachedAnalytics(type: string, entityId: number, startDate: Date, endDate: Date) {
    const cache = await this.prisma.analyticsCache.findUnique({
      where: {
        type_entityId_period: {
          type,
          entityId,
          period: this.getPeriodKey(startDate, endDate),
        },
      },
    });

    if (cache && this.isCacheValid(cache.updatedAt)) {
      return cache.data;
    }

    return null;
  }

  private async cacheAnalytics(type: string, entityId: number, startDate: Date, endDate: Date, data: any) {
    await this.prisma.analyticsCache.upsert({
      where: {
        type_entityId_period: {
          type,
          entityId,
          period: this.getPeriodKey(startDate, endDate),
        },
      },
      update: { data },
      create: {
        type,
        entityId,
        period: this.getPeriodKey(startDate, endDate),
        data,
      },
    });
  }

  private getPeriodKey(startDate: Date, endDate: Date): string {
    const diffTime = endDate.getTime() - startDate.getTime();
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffDays <= 1) return 'daily';
    if (diffDays <= 7) return 'weekly';
    if (diffDays <= 30) return 'monthly';
    return 'yearly';
  }

  private isCacheValid(updatedAt: Date): boolean {
    const now = new Date();
    const diffTime = now.getTime() - updatedAt.getTime();
    const diffHours = diffTime / (1000 * 60 * 60);
    return diffHours < 1; // Cache valid for 1 hour
  }
}
```

#### **1.2 Analytics Controller**
```typescript
// src/modules/analytics/analytics.controller.ts
import { Controller, Get, Query, UseGuards } from '@nestjs/common';
import { AnalyticsService } from './analytics.service';
import { AnalyticsQueryDto } from './dto/analytics-query.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';

@Controller('analytics')
@UseGuards(JwtAuthGuard, RolesGuard)
export class AnalyticsController {
  constructor(private analyticsService: AnalyticsService) {}

  @Get('doctor/:doctorId')
  @Roles('ADMIN', 'DOCTOR')
  async getDoctorStats(
    @Param('doctorId') doctorId: number,
    @Query() query: AnalyticsQueryDto,
  ) {
    return this.analyticsService.getDoctorStats(
      doctorId,
      new Date(query.startDate),
      new Date(query.endDate),
    );
  }

  @Get('clinic/:clinicId')
  @Roles('ADMIN')
  async getClinicStats(
    @Param('clinicId') clinicId: number,
    @Query() query: AnalyticsQueryDto,
  ) {
    return this.analyticsService.getClinicStats(
      clinicId,
      new Date(query.startDate),
      new Date(query.endDate),
    );
  }

  @Get('patient/:patientId')
  @Roles('ADMIN', 'DOCTOR', 'PATIENT')
  async getPatientStats(
    @Param('patientId') patientId: number,
    @Query() query: AnalyticsQueryDto,
  ) {
    return this.analyticsService.getPatientStats(
      patientId,
      new Date(query.startDate),
      new Date(query.endDate),
    );
  }

  @Get('revenue')
  @Roles('ADMIN')
  async getRevenueAnalytics(@Query() query: AnalyticsQueryDto) {
    return this.analyticsService.getRevenueAnalytics(
      new Date(query.startDate),
      new Date(query.endDate),
    );
  }
}
```

### **Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø«Ø§Ù†ÙŠ: ÙˆØ­Ø¯Ø© Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±**

#### **2.1 Ø®Ø¯Ù…Ø© Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±**
```typescript
// src/modules/reports/reports.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../database/prisma.service';
import { PDFService } from '../export/pdf.service';
import { ReportRequestDto } from './dto/report-request.dto';

@Injectable()
export class ReportsService {
  constructor(
    private prisma: PrismaService,
    private pdfService: PDFService,
  ) {}

  async generateReport(reportRequest: ReportRequestDto, userId: number) {
    // Ø¥Ù†Ø´Ø§Ø¡ Ø³Ø¬Ù„ Ø§Ù„ØªÙ‚Ø±ÙŠØ±
    const report = await this.prisma.report.create({
      data: {
        name: reportRequest.name,
        type: reportRequest.type,
        parameters: reportRequest.parameters,
        generatedBy: userId,
        status: 'PENDING',
      },
    });

    // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªÙ‚Ø±ÙŠØ± ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©
    this.processReport(report.id, reportRequest);

    return report;
  }

  async processReport(reportId: number, reportRequest: ReportRequestDto) {
    try {
      // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ØªÙ‚Ø±ÙŠØ±
      await this.prisma.report.update({
        where: { id: reportId },
        data: { status: 'PROCESSING' },
      });

      let reportData;
      let template;

      switch (reportRequest.type) {
        case 'APPOINTMENT':
          reportData = await this.generateAppointmentReport(reportRequest.parameters);
          template = 'appointment-report';
          break;
        case 'FINANCIAL':
          reportData = await this.generateFinancialReport(reportRequest.parameters);
          template = 'financial-report';
          break;
        case 'DOCTOR_PERFORMANCE':
          reportData = await this.generateDoctorPerformanceReport(reportRequest.parameters);
          template = 'doctor-report';
          break;
        default:
          throw new Error('Ù†ÙˆØ¹ Ø§Ù„ØªÙ‚Ø±ÙŠØ± ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…');
      }

      // ØªÙˆÙ„ÙŠØ¯ Ù…Ù„Ù PDF
      const pdfBuffer = await this.pdfService.generatePDF(template, reportData);
      
      // Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù Ø¥Ù„Ù‰ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø³Ø­Ø§Ø¨ÙŠ
      const fileUrl = await this.uploadReportFile(reportId, pdfBuffer);

      // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ‚Ø±ÙŠØ±
      await this.prisma.report.update({
        where: { id: reportId },
        data: {
          status: 'COMPLETED',
          fileUrl,
          completedAt: new Date(),
        },
      });

    } catch (error) {
      await this.prisma.report.update({
        where: { id: reportId },
        data: { status: 'FAILED' },
      });
      throw error;
    }
  }

  async generateAppointmentReport(parameters: any) {
    const { startDate, endDate, clinicId, doctorId } = parameters;

    const appointments = await this.prisma.appointment.findMany({
      where: {
        appointmentDate: {
          gte: new Date(startDate),
          lte: new Date(endDate),
        },
        ...(clinicId && { clinicId }),
        ...(doctorId && { doctorId }),
      },
      include: {
        patient: {
          include: { profile: true },
        },
        doctor: {
          include: { profile: true },
        },
        clinic: true,
        department: true,
      },
    });

    const stats = {
      totalAppointments: appointments.length,
      completedAppointments: appointments.filter(a => a.status === 'COMPLETED').length,
      cancelledAppointments: appointments.filter(a => a.status === 'CANCELLED').length,
      noShowAppointments: appointments.filter(a => a.status === 'NO_SHOW').length,
      completionRate: appointments.length > 0 
        ? (appointments.filter(a => a.status === 'COMPLETED').length / appointments.length) * 100 
        : 0,
    };

    return {
      title: 'ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯',
      period: `${startDate} - ${endDate}`,
      stats,
      appointments: appointments.map(appointment => ({
        id: appointment.id,
        patientName: `${appointment.patient.profile.firstName} ${appointment.patient.profile.lastName}`,
        doctorName: `${appointment.doctor.profile.firstName} ${appointment.doctor.profile.lastName}`,
        clinicName: appointment.clinic.name,
        departmentName: appointment.department.name,
        appointmentDate: appointment.appointmentDate,
        appointmentTime: appointment.appointmentTime,
        status: appointment.status,
      })),
    };
  }

  async generateFinancialReport(parameters: any) {
    const { startDate, endDate, clinicId } = parameters;

    const payments = await this.prisma.payment.findMany({
      where: {
        createdAt: {
          gte: new Date(startDate),
          lte: new Date(endDate),
        },
        ...(clinicId && {
          appointment: { clinicId },
        }),
      },
      include: {
        appointment: {
          include: {
            clinic: true,
            doctor: {
              include: { profile: true },
            },
          },
        },
      },
    });

    const totalRevenue = payments
      .filter(p => p.status === 'COMPLETED')
      .reduce((sum, p) => sum + Number(p.amount), 0);

    const totalRefunds = payments
      .filter(p => p.status === 'REFUNDED')
      .reduce((sum, p) => sum + Number(p.refundAmount || 0), 0);

    const paymentMethodStats = this.calculatePaymentMethodStats(payments);

    return {
      title: 'Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù…Ø§Ù„ÙŠ',
      period: `${startDate} - ${endDate}`,
      totalRevenue,
      totalRefunds,
      netRevenue: totalRevenue - totalRefunds,
      paymentMethodStats,
      payments: payments.map(payment => ({
        id: payment.id,
        amount: payment.amount,
        currency: payment.currency,
        paymentMethod: payment.paymentMethod,
        status: payment.status,
        createdAt: payment.createdAt,
        clinicName: payment.appointment.clinic.name,
        doctorName: `${payment.appointment.doctor.profile.firstName} ${payment.appointment.doctor.profile.lastName}`,
      })),
    };
  }

  async generateDoctorPerformanceReport(parameters: any) {
    const { startDate, endDate, doctorId } = parameters;

    const doctor = await this.prisma.doctor.findUnique({
      where: { id: doctorId },
      include: {
        user: {
          include: { profile: true },
        },
        clinic: true,
        department: true,
      },
    });

    const appointments = await this.prisma.appointment.findMany({
      where: {
        doctorId,
        appointmentDate: {
          gte: new Date(startDate),
          lte: new Date(endDate),
        },
      },
    });

    const consultations = await this.prisma.consultation.findMany({
      where: {
        appointment: {
          doctorId,
          appointmentDate: {
            gte: new Date(startDate),
            lte: new Date(endDate),
          },
        },
      },
    });

    const ratings = await this.prisma.rating.findMany({
      where: {
        doctorId,
        createdAt: {
          gte: new Date(startDate),
          lte: new Date(endDate),
        },
      },
    });

    const stats = {
      totalAppointments: appointments.length,
      completedAppointments: appointments.filter(a => a.status === 'COMPLETED').length,
      totalConsultations: consultations.length,
      completedConsultations: consultations.filter(c => c.status === 'COMPLETED').length,
      averageRating: ratings.length > 0 
        ? ratings.reduce((sum, r) => sum + r.rating, 0) / ratings.length 
        : 0,
      totalRatings: ratings.length,
    };

    return {
      title: 'ØªÙ‚Ø±ÙŠØ± Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø·Ø¨ÙŠØ¨',
      period: `${startDate} - ${endDate}`,
      doctor: {
        name: `${doctor.user.profile.firstName} ${doctor.user.profile.lastName}`,
        specialization: doctor.specialization,
        clinic: doctor.clinic.name,
        department: doctor.department.name,
      },
      stats,
      ratings: ratings.map(rating => ({
        rating: rating.rating,
        review: rating.review,
        createdAt: rating.createdAt,
      })),
    };
  }

  private calculatePaymentMethodStats(payments: any[]) {
    const methodStats = {};
    payments
      .filter(p => p.status === 'COMPLETED')
      .forEach(payment => {
        const method = payment.paymentMethod;
        if (!methodStats[method]) {
          methodStats[method] = { count: 0, total: 0 };
        }
        methodStats[method].count++;
        methodStats[method].total += Number(payment.amount);
      });
    return methodStats;
  }

  private async uploadReportFile(reportId: number, buffer: Buffer): Promise<string> {
    // Ù…Ù†Ø·Ù‚ Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù Ø¥Ù„Ù‰ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø³Ø­Ø§Ø¨ÙŠ
    // ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… AWS S3 Ø£Ùˆ Google Cloud Storage
    return `https://storage.example.com/reports/${reportId}.pdf`;
  }

  async getUserReports(userId: number) {
    return this.prisma.report.findMany({
      where: { generatedBy: userId },
      orderBy: { createdAt: 'desc' },
    });
  }

  async getReport(reportId: number) {
    return this.prisma.report.findUnique({
      where: { id: reportId },
    });
  }
}
```

### **Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø«Ø§Ù„Ø«: ÙˆØ­Ø¯Ø© Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…**

#### **3.1 Ø®Ø¯Ù…Ø© Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…**
```typescript
// src/modules/dashboard/dashboard.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../database/prisma.service';
import { AnalyticsService } from '../analytics/analytics.service';

@Injectable()
export class DashboardService {
  constructor(
    private prisma: PrismaService,
    private analyticsService: AnalyticsService,
  ) {}

  async getDashboardData(userId: number, userRole: string) {
    const now = new Date();
    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
    const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);

    switch (userRole) {
      case 'ADMIN':
        return this.getAdminDashboard(userId, startOfMonth, endOfMonth);
      case 'DOCTOR':
        return this.getDoctorDashboard(userId, startOfMonth, endOfMonth);
      case 'PATIENT':
        return this.getPatientDashboard(userId, startOfMonth, endOfMonth);
      default:
        throw new Error('Ø¯ÙˆØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…');
    }
  }

  async getAdminDashboard(userId: number, startDate: Date, endDate: Date) {
    const [
      totalAppointments,
      totalRevenue,
      totalPatients,
      totalDoctors,
      recentAppointments,
      revenueChart,
      appointmentChart,
    ] = await Promise.all([
      this.getTotalAppointments(startDate, endDate),
      this.getTotalRevenue(startDate, endDate),
      this.getTotalPatients(),
      this.getTotalDoctors(),
      this.getRecentAppointments(10),
      this.getRevenueChart(startDate, endDate),
      this.getAppointmentChart(startDate, endDate),
    ]);

    return {
      summary: {
        totalAppointments,
        totalRevenue,
        totalPatients,
        totalDoctors,
      },
      charts: {
        revenue: revenueChart,
        appointments: appointmentChart,
      },
      recentAppointments,
    };
  }

  async getDoctorDashboard(userId: number, startDate: Date, endDate: Date) {
    const doctor = await this.prisma.doctor.findUnique({
      where: { userId },
    });

    if (!doctor) {
      throw new Error('Ø§Ù„Ø·Ø¨ÙŠØ¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
    }

    const [
      myStats,
      myAppointments,
      myConsultations,
      myRatings,
    ] = await Promise.all([
      this.analyticsService.getDoctorStats(doctor.id, startDate, endDate),
      this.getMyAppointments(doctor.id, 10),
      this.getMyConsultations(doctor.id, 10),
      this.getMyRatings(doctor.id, 10),
    ]);

    return {
      stats: myStats,
      recentAppointments: myAppointments,
      recentConsultations: myConsultations,
      recentRatings: myRatings,
    };
  }

  async getPatientDashboard(userId: number, startDate: Date, endDate: Date) {
    const [
      myStats,
      myAppointments,
      myConsultations,
      myPayments,
    ] = await Promise.all([
      this.analyticsService.getPatientStats(userId, startDate, endDate),
      this.getMyAppointments(userId, 10),
      this.getMyConsultations(userId, 10),
      this.getMyPayments(userId, 10),
    ]);

    return {
      stats: myStats,
      recentAppointments: myAppointments,
      recentConsultations: myConsultations,
      recentPayments: myPayments,
    };
  }

  private async getTotalAppointments(startDate: Date, endDate: Date) {
    return this.prisma.appointment.count({
      where: {
        appointmentDate: {
          gte: startDate,
          lte: endDate,
        },
      },
    });
  }

  private async getTotalRevenue(startDate: Date, endDate: Date) {
    const payments = await this.prisma.payment.findMany({
      where: {
        createdAt: {
          gte: startDate,
          lte: endDate,
        },
        status: 'COMPLETED',
      },
    });

    return payments.reduce((sum, payment) => sum + Number(payment.amount), 0);
  }

  private async getTotalPatients() {
    return this.prisma.user.count({
      where: { role: 'PATIENT' },
    });
  }

  private async getTotalDoctors() {
    return this.prisma.doctor.count();
  }

  private async getRecentAppointments(limit: number) {
    return this.prisma.appointment.findMany({
      take: limit,
      orderBy: { createdAt: 'desc' },
      include: {
        patient: {
          include: { profile: true },
        },
        doctor: {
          include: { profile: true },
        },
        clinic: true,
      },
    });
  }

  private async getRevenueChart(startDate: Date, endDate: Date) {
    const payments = await this.prisma.payment.findMany({
      where: {
        createdAt: {
          gte: startDate,
          lte: endDate,
        },
        status: 'COMPLETED',
      },
    });

    const dailyRevenue = {};
    payments.forEach(payment => {
      const date = payment.createdAt.toISOString().split('T')[0];
      dailyRevenue[date] = (dailyRevenue[date] || 0) + Number(payment.amount);
    });

    return Object.entries(dailyRevenue).map(([date, revenue]) => ({
      date,
      revenue,
    }));
  }

  private async getAppointmentChart(startDate: Date, endDate: Date) {
    const appointments = await this.prisma.appointment.findMany({
      where: {
        appointmentDate: {
          gte: startDate,
          lte: endDate,
        },
      },
    });

    const dailyAppointments = {};
    appointments.forEach(appointment => {
      const date = appointment.appointmentDate.toISOString().split('T')[0];
      dailyAppointments[date] = (dailyAppointments[date] || 0) + 1;
    });

    return Object.entries(dailyAppointments).map(([date, count]) => ({
      date,
      count,
    }));
  }

  private async getMyAppointments(doctorId: number, limit: number) {
    return this.prisma.appointment.findMany({
      where: { doctorId },
      take: limit,
      orderBy: { appointmentDate: 'desc' },
      include: {
        patient: {
          include: { profile: true },
        },
        clinic: true,
        department: true,
      },
    });
  }

  private async getMyConsultations(doctorId: number, limit: number) {
    return this.prisma.consultation.findMany({
      where: {
        appointment: { doctorId },
      },
      take: limit,
      orderBy: { createdAt: 'desc' },
      include: {
        appointment: {
          include: {
            patient: {
              include: { profile: true },
            },
          },
        },
      },
    });
  }

  private async getMyRatings(doctorId: number, limit: number) {
    return this.prisma.rating.findMany({
      where: { doctorId },
      take: limit,
      orderBy: { createdAt: 'desc' },
      include: {
        patient: {
          include: { profile: true },
        },
        appointment: true,
      },
    });
  }

  private async getMyPayments(patientId: number, limit: number) {
    return this.prisma.payment.findMany({
      where: {
        appointment: { patientId },
      },
      take: limit,
      orderBy: { createdAt: 'desc' },
      include: {
        appointment: {
          include: {
            doctor: {
              include: { profile: true },
            },
            clinic: true,
          },
        },
      },
    });
  }
}
```

### **Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø±Ø§Ø¨Ø¹: Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ÙˆØªØ­Ø³ÙŠÙ†Ø§Øª**

#### **4.1 Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª**
```typescript
// test/unit/analytics.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AnalyticsService } from '../../src/modules/analytics/analytics.service';
import { PrismaService } from '../../src/database/prisma.service';

describe('AnalyticsService', () => {
  let service: AnalyticsService;
  let prismaService: PrismaService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AnalyticsService,
        {
          provide: PrismaService,
          useValue: {
            appointment: {
              findMany: jest.fn(),
            },
            consultation: {
              findMany: jest.fn(),
            },
            rating: {
              findMany: jest.fn(),
            },
            analyticsCache: {
              findUnique: jest.fn(),
              upsert: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    service = module.get<AnalyticsService>(AnalyticsService);
    prismaService = module.get<PrismaService>(PrismaService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should get doctor stats', async () => {
    const mockAppointments = [
      { id: 1, status: 'COMPLETED' },
      { id: 2, status: 'CANCELLED' },
    ];
    const mockConsultations = [
      { id: 1, status: 'COMPLETED', duration: 30 },
    ];
    const mockRatings = [
      { id: 1, rating: 5 },
      { id: 2, rating: 4 },
    ];

    jest.spyOn(prismaService.appointment, 'findMany').mockResolvedValue(mockAppointments);
    jest.spyOn(prismaService.consultation, 'findMany').mockResolvedValue(mockConsultations);
    jest.spyOn(prismaService.rating, 'findMany').mockResolvedValue(mockRatings);
    jest.spyOn(prismaService.analyticsCache, 'findUnique').mockResolvedValue(null);

    const result = await service.getDoctorStats(1, new Date(), new Date());
    
    expect(result.totalAppointments).toBe(2);
    expect(result.completedAppointments).toBe(1);
    expect(result.averageRating).toBe(4.5);
  });
});
```

#### **4.2 Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±**
```typescript
// test/unit/reports.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { ReportsService } from '../../src/modules/reports/reports.service';
import { PrismaService } from '../../src/database/prisma.service';
import { PDFService } from '../../src/modules/export/pdf.service';

describe('ReportsService', () => {
  let service: ReportsService;
  let prismaService: PrismaService;
  let pdfService: PDFService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ReportsService,
        {
          provide: PrismaService,
          useValue: {
            report: {
              create: jest.fn(),
              update: jest.fn(),
              findMany: jest.fn(),
              findUnique: jest.fn(),
            },
            appointment: {
              findMany: jest.fn(),
            },
            payment: {
              findMany: jest.fn(),
            },
          },
        },
        {
          provide: PDFService,
          useValue: {
            generatePDF: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get<ReportsService>(ReportsService);
    prismaService = module.get<PrismaService>(PrismaService);
    pdfService = module.get<PDFService>(PDFService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should generate a report', async () => {
    const reportRequest = {
      name: 'Test Report',
      type: 'APPOINTMENT',
      parameters: {
        startDate: '2024-01-01',
        endDate: '2024-01-31',
      },
    };

    const expectedResult = { id: 1, ...reportRequest, status: 'PENDING' };
    jest.spyOn(prismaService.report, 'create').mockResolvedValue(expectedResult);

    const result = await service.generateReport(reportRequest, 1);
    expect(result).toEqual(expectedResult);
  });
});
```

---

## ğŸ”§ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©

### **Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø© Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ©**
```env
# Analytics
ANALYTICS_CACHE_TTL=3600  # 1 hour in seconds
ANALYTICS_BATCH_SIZE=1000

# Reports
REPORTS_STORAGE_PATH=/tmp/reports
REPORTS_RETENTION_DAYS=30

# Dashboard
DASHBOARD_CACHE_TTL=1800  # 30 minutes in seconds
DASHBOARD_MAX_WIDGETS=20

# Export
PDF_GENERATION_TIMEOUT=30000  # 30 seconds
EXPORT_MAX_FILE_SIZE=10485760  # 10MB
```

---

## ğŸ“Š Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ù†Ø¬Ø§Ø­

### **Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**
1. âœ… Ù†Ø¸Ø§Ù… ØªØ­Ù„ÙŠÙ„Ø§Øª Ù…ØªÙƒØ§Ù…Ù„ ÙŠØ¹Ù…Ù„
2. âœ… ØªÙ‚Ø§Ø±ÙŠØ± PDF ØªÙˆÙ„Ø¯ Ø¨Ù†Ø¬Ø§Ø­
3. âœ… Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… ØªÙØ§Ø¹Ù„ÙŠØ© ØªØ¹Ù…Ù„
4. âœ… ØªØµØ¯ÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙŠØ¹Ù…Ù„
5. âœ… Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„Ø© ØªØ¹Ù…Ù„
6. âœ… Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø´Ø§Ù…Ù„Ø© ØªØ¹Ù…Ù„

### **Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**
- [ ] ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ø£Ø·Ø¨Ø§Ø¡
- [ ] ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ø¹ÙŠØ§Ø¯Ø§Øª
- [ ] ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø±Ø¶Ù‰
- [ ] ØªÙ‚Ø§Ø±ÙŠØ± Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯
- [ ] Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ± Ø§Ù„Ù…Ø§Ù„ÙŠØ©
- [ ] Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…

---

## ğŸš€ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©

Ø¨Ø¹Ø¯ Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø®Ø§Ù…Ø³Ø©ØŒ Ø³ØªÙƒÙˆÙ† Ø¬Ø§Ù‡Ø²Ø§Ù‹ Ù„Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰:
- **Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø³Ø§Ø¯Ø³Ø©:** Ø§Ù„Ù†Ø´Ø± ÙˆØ§Ù„Ø¥Ù†ØªØ§Ø¬

---

*Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø© ØªØ¶ÙŠÙ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„ÙŠØ© Ù„Ù„Ù†Ø¸Ø§Ù… Ù…Ø¹ Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ± ÙˆØ§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©*
