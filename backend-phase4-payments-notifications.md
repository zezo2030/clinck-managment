# ğŸ’³ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø±Ø§Ø¨Ø¹Ø©: Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª ÙˆØ§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª - Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¹ÙŠØ§Ø¯Ø§Øª

## ğŸ“‹ Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø±Ø§Ø¨Ø¹Ø©

Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø© ØªØ±ÙƒØ² Ø¹Ù„Ù‰ ØªØ·ÙˆÙŠØ± Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª Ø§Ù„Ø´Ø§Ù…Ù„ Ù…Ø¹ Ø¯Ø¹Ù… Stripe ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©.

**Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ù…Ù‚Ø¯Ø±Ø©:** 4 Ø£Ø³Ø§Ø¨ÙŠØ¹  
**Ø§Ù„Ù‡Ø¯Ù:** ØªØ·ÙˆÙŠØ± Ù†Ø¸Ø§Ù… Ù…Ø¯ÙÙˆØ¹Ø§Øª Ù…ØªÙƒØ§Ù…Ù„ Ù…Ø¹ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø°ÙƒÙŠØ©

---

## ğŸ› ï¸ Ø§Ù„ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©

### **Core Framework:**
- **NestJS** - Ø¥Ø·Ø§Ø± Ø¹Ù…Ù„ Node.js Ù…ØªÙ‚Ø¯Ù…
- **TypeScript** - Ù„ØºØ© Ø§Ù„Ø¨Ø±Ù…Ø¬Ø©
- **Node.js** - Ø¨ÙŠØ¦Ø© Ø§Ù„ØªØ´ØºÙŠÙ„

### **Database:**
- **PostgreSQL** - Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
- **Prisma** - ORM Ù„Ø¥Ø¯Ø§Ø±Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
- **Redis** - ØªØ®Ø²ÙŠÙ† Ù…Ø¤Ù‚Øª Ù„Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª

### **Payment Processing:**
- **Stripe** - Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª
- **PayPal** - Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª Ø§Ù„Ø¨Ø¯ÙŠÙ„Ø©

### **Notifications:**
- **Firebase Admin SDK** - Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
- **SendGrid** - Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„Ø§Øª
- **Twilio** - Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†ØµÙŠØ©

### **Background Jobs:**
- **Bull Queue** - Ø§Ù„Ù…Ù‡Ø§Ù… ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©
- **Cron Jobs** - Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„Ø©

---

## ğŸ—ï¸ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ù„Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø±Ø§Ø¨Ø¹Ø©

```
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ modules/
â”‚   â”‚   â”œâ”€â”€ payments/          # ÙˆØ­Ø¯Ø© Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª
â”‚   â”‚   â”‚   â”œâ”€â”€ payments.controller.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ payments.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ payments.module.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ create-payment.dto.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ process-payment.dto.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ refund-payment.dto.ts
â”‚   â”‚   â”‚   â””â”€â”€ entities/
â”‚   â”‚   â”‚       â””â”€â”€ payment.entity.ts
â”‚   â”‚   â”œâ”€â”€ notifications/     # ÙˆØ­Ø¯Ø© Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
â”‚   â”‚   â”‚   â”œâ”€â”€ notifications.controller.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ notifications.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ notifications.module.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â””â”€â”€ entities/
â”‚   â”‚   â”œâ”€â”€ stripe/            # ÙˆØ­Ø¯Ø© Stripe
â”‚   â”‚   â”‚   â”œâ”€â”€ stripe.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ stripe.controller.ts
â”‚   â”‚   â”‚   â””â”€â”€ stripe.module.ts
â”‚   â”‚   â”œâ”€â”€ firebase/          # ÙˆØ­Ø¯Ø© Firebase
â”‚   â”‚   â”‚   â”œâ”€â”€ firebase.service.ts
â”‚   â”‚   â”‚   â””â”€â”€ firebase.module.ts
â”‚   â”‚   â””â”€â”€ email/             # ÙˆØ­Ø¯Ø© Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„
â”‚   â”‚       â”œâ”€â”€ email.service.ts
â”‚   â”‚       â”œâ”€â”€ email.controller.ts
â”‚   â”‚       â””â”€â”€ email.module.ts
â”‚   â”œâ”€â”€ common/
â”‚   â”‚   â”œâ”€â”€ schedulers/        # Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„Ø©
â”‚   â”‚   â”‚   â”œâ”€â”€ payment-reminder.scheduler.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ appointment-reminder.scheduler.ts
â”‚   â”‚   â”‚   â””â”€â”€ notification.scheduler.ts
â”‚   â”‚   â”œâ”€â”€ queues/            # Ø·ÙˆØ§Ø¨ÙŠØ± Ø§Ù„Ù…Ù‡Ø§Ù…
â”‚   â”‚   â”‚   â”œâ”€â”€ payment.queue.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ notification.queue.ts
â”‚   â”‚   â”‚   â””â”€â”€ email.queue.ts
â”‚   â”‚   â””â”€â”€ utils/
â”‚   â”‚       â”œâ”€â”€ payment.util.ts
â”‚   â”‚       â””â”€â”€ notification.util.ts
â”‚   â””â”€â”€ config/
â”‚       â”œâ”€â”€ stripe.config.ts
â”‚       â”œâ”€â”€ firebase.config.ts
â”‚       â””â”€â”€ email.config.ts
```

---

## ğŸ—„ï¸ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª - Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø±Ø§Ø¨Ø¹Ø©

### **Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©**

```prisma
// Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª
model Payment {
  id            Int         @id @default(autoincrement())
  appointmentId Int         @unique
  amount        Decimal     @db.Decimal(10, 2)
  currency      String      @default("USD")
  paymentMethod PaymentMethod
  status        PaymentStatus @default(PENDING)
  transactionId String?
  refundAmount  Decimal?    @db.Decimal(10, 2)
  refundReason  String?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  appointment Appointment @relation(fields: [appointmentId], references: [id])

  @@map("payments")
}

// Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
model Notification {
  id        Int      @id @default(autoincrement())
  userId    Int
  title     String
  message   String
  type      NotificationType
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  user User @relation(fields: [userId], references: [id])

  @@map("notifications")
}

// Ø¬Ø¯ÙˆÙ„ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
model NotificationSettings {
  id                    Int      @id @default(autoincrement())
  userId                Int      @unique
  emailNotifications    Boolean  @default(true)
  smsNotifications      Boolean  @default(true)
  pushNotifications     Boolean  @default(true)
  appointmentReminders  Boolean  @default(true)
  paymentReminders      Boolean  @default(true)
  systemUpdates         Boolean  @default(true)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  user User @relation(fields: [userId], references: [id])

  @@map("notification_settings")
}

// Enums
enum PaymentMethod {
  CARD
  PAYPAL
  CASH
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum NotificationType {
  APPOINTMENT
  PAYMENT
  MESSAGE
  SYSTEM
}
```

---

## ğŸš€ Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªÙ†ÙÙŠØ°

### **Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø£ÙˆÙ„: Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª**

#### **1.1 ÙˆØ­Ø¯Ø© Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª**
```typescript
// src/modules/payments/payments.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../database/prisma.service';
import { StripeService } from '../stripe/stripe.service';
import { CreatePaymentDto } from './dto/create-payment.dto';

@Injectable()
export class PaymentsService {
  constructor(
    private prisma: PrismaService,
    private stripeService: StripeService,
  ) {}

  async createPayment(createPaymentDto: CreatePaymentDto) {
    // Ø¥Ù†Ø´Ø§Ø¡ payment intent ÙÙŠ Stripe
    const paymentIntent = await this.stripeService.createPaymentIntent(
      createPaymentDto.amount,
      createPaymentDto.currency,
      createPaymentDto.paymentMethod,
    );

    return this.prisma.payment.create({
      data: {
        appointmentId: createPaymentDto.appointmentId,
        amount: createPaymentDto.amount,
        currency: createPaymentDto.currency,
        paymentMethod: createPaymentDto.paymentMethod,
        transactionId: paymentIntent.id,
        status: 'PENDING',
      },
    });
  }

  async confirmPayment(paymentId: number) {
    const payment = await this.prisma.payment.findUnique({
      where: { id: paymentId },
    });

    if (!payment) {
      throw new Error('Ø§Ù„Ø¯ÙØ¹Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©');
    }

    // ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹ ÙÙŠ Stripe
    await this.stripeService.confirmPaymentIntent(payment.transactionId);

    return this.prisma.payment.update({
      where: { id: paymentId },
      data: {
        status: 'COMPLETED',
      },
    });
  }

  async refundPayment(paymentId: number, amount?: number, reason?: string) {
    const payment = await this.prisma.payment.findUnique({
      where: { id: paymentId },
    });

    if (!payment) {
      throw new Error('Ø§Ù„Ø¯ÙØ¹Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©');
    }

    const refundAmount = amount || payment.amount;

    // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø§Ø³ØªØ±Ø¯Ø§Ø¯ ÙÙŠ Stripe
    await this.stripeService.createRefund(payment.transactionId, refundAmount);

    return this.prisma.payment.update({
      where: { id: paymentId },
      data: {
        status: 'REFUNDED',
        refundAmount,
        refundReason: reason,
      },
    });
  }

  async getPaymentHistory(userId: number) {
    return this.prisma.payment.findMany({
      where: {
        appointment: {
          OR: [
            { patientId: userId },
            { doctorId: userId },
          ],
        },
      },
      include: {
        appointment: {
          include: {
            patient: {
              include: { profile: true },
            },
            doctor: {
              include: { profile: true },
            },
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async getPaymentStats(startDate: Date, endDate: Date) {
    const payments = await this.prisma.payment.findMany({
      where: {
        createdAt: {
          gte: startDate,
          lte: endDate,
        },
      },
    });

    const totalRevenue = payments
      .filter(p => p.status === 'COMPLETED')
      .reduce((sum, p) => sum + Number(p.amount), 0);

    const totalRefunds = payments
      .filter(p => p.status === 'REFUNDED')
      .reduce((sum, p) => sum + Number(p.refundAmount || 0), 0);

    return {
      totalPayments: payments.length,
      completedPayments: payments.filter(p => p.status === 'COMPLETED').length,
      failedPayments: payments.filter(p => p.status === 'FAILED').length,
      refundedPayments: payments.filter(p => p.status === 'REFUNDED').length,
      totalRevenue,
      totalRefunds,
      netRevenue: totalRevenue - totalRefunds,
    };
  }
}
```

#### **1.2 Ø®Ø¯Ù…Ø© Stripe**
```typescript
// src/modules/stripe/stripe.service.ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import Stripe from 'stripe';

@Injectable()
export class StripeService {
  private stripe: Stripe;

  constructor(private configService: ConfigService) {
    this.stripe = new Stripe(this.configService.get('STRIPE_SECRET_KEY'), {
      apiVersion: '2023-10-16',
    });
  }

  async createPaymentIntent(amount: number, currency: string, paymentMethod: string) {
    const paymentIntent = await this.stripe.paymentIntents.create({
      amount: Math.round(amount * 100), // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø³Ù†Øª
      currency: currency.toLowerCase(),
      payment_method_types: [paymentMethod.toLowerCase()],
      metadata: {
        source: 'clinic_management_system',
      },
    });

    return paymentIntent;
  }

  async confirmPaymentIntent(paymentIntentId: string) {
    return this.stripe.paymentIntents.confirm(paymentIntentId);
  }

  async createRefund(paymentIntentId: string, amount: number) {
    return this.stripe.refunds.create({
      payment_intent: paymentIntentId,
      amount: Math.round(amount * 100),
    });
  }

  async createCustomer(email: string, name: string) {
    return this.stripe.customers.create({
      email,
      name,
    });
  }

  async createSetupIntent(customerId: string) {
    return this.stripe.setupIntents.create({
      customer: customerId,
      payment_method_types: ['card'],
    });
  }

  async getPaymentMethods(customerId: string) {
    return this.stripe.paymentMethods.list({
      customer: customerId,
      type: 'card',
    });
  }

  async webhookHandler(payload: string, signature: string) {
    const webhookSecret = this.configService.get('STRIPE_WEBHOOK_SECRET');
    
    try {
      const event = this.stripe.webhooks.constructEvent(payload, signature, webhookSecret);
      return this.handleStripeEvent(event);
    } catch (err) {
      throw new Error(`Webhook signature verification failed: ${err.message}`);
    }
  }

  private async handleStripeEvent(event: Stripe.Event) {
    switch (event.type) {
      case 'payment_intent.succeeded':
        await this.handlePaymentSucceeded(event.data.object as Stripe.PaymentIntent);
        break;
      case 'payment_intent.payment_failed':
        await this.handlePaymentFailed(event.data.object as Stripe.PaymentIntent);
        break;
      default:
        console.log(`Unhandled event type: ${event.type}`);
    }
  }

  private async handlePaymentSucceeded(paymentIntent: Stripe.PaymentIntent) {
    // Ù…Ù†Ø·Ù‚ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¯ÙØ¹ Ø§Ù„Ù†Ø§Ø¬Ø­
    console.log('Payment succeeded:', paymentIntent.id);
  }

  private async handlePaymentFailed(paymentIntent: Stripe.PaymentIntent) {
    // Ù…Ù†Ø·Ù‚ Ù…Ø¹Ø§Ù„Ø¬Ø© ÙØ´Ù„ Ø§Ù„Ø¯ÙØ¹
    console.log('Payment failed:', paymentIntent.id);
  }
}
```

### **Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø«Ø§Ù†ÙŠ: Ù†Ø¸Ø§Ù… Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª**

#### **2.1 ÙˆØ­Ø¯Ø© Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª**
```typescript
// src/modules/notifications/notifications.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../database/prisma.service';
import { FirebaseService } from '../firebase/firebase.service';
import { EmailService } from '../email/email.service';

@Injectable()
export class NotificationsService {
  constructor(
    private prisma: PrismaService,
    private firebaseService: FirebaseService,
    private emailService: EmailService,
  ) {}

  async sendNotification(userId: number, notification: any) {
    // Ø­ÙØ¸ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    const savedNotification = await this.prisma.notification.create({
      data: {
        userId,
        title: notification.title,
        message: notification.message,
        type: notification.type,
      },
    });

    // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Firebase
    await this.firebaseService.sendNotification(userId, notification);

    // Ø¥Ø±Ø³Ø§Ù„ Ø¥ÙŠÙ…ÙŠÙ„ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙØ¹Ù„
    const settings = await this.getNotificationSettings(userId);
    if (settings.emailNotifications) {
      await this.emailService.sendEmail(userId, {
        subject: notification.title,
        body: notification.message,
      });
    }

    return savedNotification;
  }

  async sendAppointmentReminder(appointmentId: number) {
    const appointment = await this.prisma.appointment.findUnique({
      where: { id: appointmentId },
      include: {
        patient: {
          include: { profile: true },
        },
        doctor: {
          include: { profile: true },
        },
      },
    });

    if (!appointment) {
      throw new Error('Ø§Ù„Ù…ÙˆØ¹Ø¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
    }

    const notification = {
      title: 'ØªØ°ÙƒÙŠØ± Ø¨Ø§Ù„Ù…ÙˆØ¹Ø¯',
      message: `Ù…ÙˆØ¹Ø¯Ùƒ Ù…Ø¹ Ø¯. ${appointment.doctor.profile.firstName} ÙÙŠ ${appointment.appointmentDate.toLocaleDateString()} Ø§Ù„Ø³Ø§Ø¹Ø© ${appointment.appointmentTime.toLocaleTimeString()}`,
      type: 'APPOINTMENT',
    };

    return this.sendNotification(appointment.patientId, notification);
  }

  async sendPaymentConfirmation(paymentId: number) {
    const payment = await this.prisma.payment.findUnique({
      where: { id: paymentId },
      include: {
        appointment: {
          include: {
            patient: {
              include: { profile: true },
            },
          },
        },
      },
    });

    if (!payment) {
      throw new Error('Ø§Ù„Ø¯ÙØ¹Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©');
    }

    const notification = {
      title: 'ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹',
      message: `ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø¯ÙØ¹ Ù…Ø¨Ù„Øº ${payment.amount} Ø¯ÙˆÙ„Ø§Ø± Ø¨Ù†Ø¬Ø§Ø­`,
      type: 'PAYMENT',
    };

    return this.sendNotification(payment.appointment.patientId, notification);
  }

  async sendBulkNotification(userIds: number[], notification: any) {
    const notifications = userIds.map(userId => ({
      userId,
      title: notification.title,
      message: notification.message,
      type: notification.type,
    }));

    await this.prisma.notification.createMany({
      data: notifications,
    });

    // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Firebase
    await Promise.all(
      userIds.map(userId => 
        this.firebaseService.sendNotification(userId, notification)
      )
    );
  }

  async getUserNotifications(userId: number, page: number = 1, limit: number = 10) {
    return this.prisma.notification.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      skip: (page - 1) * limit,
      take: limit,
    });
  }

  async markAsRead(notificationId: number) {
    return this.prisma.notification.update({
      where: { id: notificationId },
      data: { isRead: true },
    });
  }

  async markAllAsRead(userId: number) {
    return this.prisma.notification.updateMany({
      where: { userId, isRead: false },
      data: { isRead: true },
    });
  }

  async getNotificationSettings(userId: number) {
    let settings = await this.prisma.notificationSettings.findUnique({
      where: { userId },
    });

    if (!settings) {
      settings = await this.prisma.notificationSettings.create({
        data: { userId },
      });
    }

    return settings;
  }

  async updateNotificationSettings(userId: number, settings: any) {
    return this.prisma.notificationSettings.upsert({
      where: { userId },
      update: settings,
      create: { userId, ...settings },
    });
  }
}
```

#### **2.2 Ø®Ø¯Ù…Ø© Firebase**
```typescript
// src/modules/firebase/firebase.service.ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as admin from 'firebase-admin';

@Injectable()
export class FirebaseService {
  constructor(private configService: ConfigService) {
    this.initializeFirebase();
  }

  private initializeFirebase() {
    if (!admin.apps.length) {
      admin.initializeApp({
        credential: admin.credential.cert({
          projectId: this.configService.get('FIREBASE_PROJECT_ID'),
          privateKey: this.configService.get('FIREBASE_PRIVATE_KEY'),
          clientEmail: this.configService.get('FIREBASE_CLIENT_EMAIL'),
        }),
      });
    }
  }

  async sendNotification(userId: number, notification: any) {
    try {
      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM token Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
      const user = await this.getUserFCMToken(userId);
      
      if (!user.fcmToken) {
        console.log(`No FCM token for user ${userId}`);
        return;
      }

      const message = {
        token: user.fcmToken,
        notification: {
          title: notification.title,
          body: notification.message,
        },
        data: {
          type: notification.type,
          userId: userId.toString(),
        },
        android: {
          notification: {
            icon: 'ic_notification',
            color: '#FF6B6B',
          },
        },
        apns: {
          payload: {
            aps: {
              sound: 'default',
              badge: 1,
            },
          },
        },
      };

      const response = await admin.messaging().send(message);
      console.log('Successfully sent message:', response);
      
      return response;
    } catch (error) {
      console.error('Error sending notification:', error);
      throw error;
    }
  }

  async sendToTopic(topic: string, notification: any) {
    const message = {
      topic,
      notification: {
        title: notification.title,
        body: notification.message,
      },
      data: {
        type: notification.type,
      },
    };

    return admin.messaging().send(message);
  }

  async subscribeToTopic(token: string, topic: string) {
    return admin.messaging().subscribeToTopic(token, topic);
  }

  async unsubscribeFromTopic(token: string, topic: string) {
    return admin.messaging().unsubscribeFromTopic(token, topic);
  }

  private async getUserFCMToken(userId: number) {
    // Ù…Ù†Ø·Ù‚ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM token Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    // ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ø¬Ø¯ÙˆÙ„ Ù…Ù†ÙØµÙ„ Ù„ØªØ®Ø²ÙŠÙ† FCM tokens
    return { fcmToken: null };
  }
}
```

### **Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø«Ø§Ù„Ø«: Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„Ø©**

#### **3.1 Scheduler Ù„Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª**
```typescript
// src/common/schedulers/payment-reminder.scheduler.ts
import { Injectable } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { PrismaService } from '../../database/prisma.service';
import { NotificationsService } from '../../modules/notifications/notifications.service';

@Injectable()
export class PaymentReminderScheduler {
  constructor(
    private prisma: PrismaService,
    private notificationsService: NotificationsService,
  ) {}

  @Cron(CronExpression.EVERY_HOUR)
  async sendPaymentReminders() {
    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø© Ù„Ø£ÙƒØ«Ø± Ù…Ù† 24 Ø³Ø§Ø¹Ø©
    const pendingPayments = await this.prisma.payment.findMany({
      where: {
        status: 'PENDING',
        createdAt: {
          lte: new Date(Date.now() - 24 * 60 * 60 * 1000), // 24 Ø³Ø§Ø¹Ø© Ù…Ø¶Øª
        },
      },
      include: {
        appointment: {
          include: {
            patient: {
              include: { profile: true },
            },
          },
        },
      },
    });

    for (const payment of pendingPayments) {
      await this.notificationsService.sendNotification(payment.appointment.patientId, {
        title: 'ØªØ°ÙƒÙŠØ± Ø¨Ø§Ù„Ø¯ÙØ¹',
        message: `Ù„Ø¯ÙŠÙƒ Ø¯ÙØ¹Ø© Ù…Ø¹Ù„Ù‚Ø© Ø¨Ù‚ÙŠÙ…Ø© ${payment.amount} Ø¯ÙˆÙ„Ø§Ø±. ÙŠØ±Ø¬Ù‰ Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø¯ÙØ¹ ÙÙŠ Ø£Ù‚Ø±Ø¨ ÙˆÙ‚Øª.`,
        type: 'PAYMENT',
      });
    }
  }

  @Cron(CronExpression.EVERY_DAY_AT_9AM)
  async sendDailyPaymentReport() {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    yesterday.setHours(0, 0, 0, 0);

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const payments = await this.prisma.payment.findMany({
      where: {
        createdAt: {
          gte: yesterday,
          lt: today,
        },
      },
    });

    const totalRevenue = payments
      .filter(p => p.status === 'COMPLETED')
      .reduce((sum, p) => sum + Number(p.amount), 0);

    // Ø¥Ø±Ø³Ø§Ù„ ØªÙ‚Ø±ÙŠØ± ÙŠÙˆÙ…ÙŠ Ù„Ù„Ø¥Ø¯Ø§Ø±Ø©
    console.log(`Daily revenue: $${totalRevenue}`);
  }
}
```

#### **3.2 Scheduler Ù„Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯**
```typescript
// src/common/schedulers/appointment-reminder.scheduler.ts
import { Injectable } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { PrismaService } from '../../database/prisma.service';
import { NotificationsService } from '../../modules/notifications/notifications.service';

@Injectable()
export class AppointmentReminderScheduler {
  constructor(
    private prisma: PrismaService,
    private notificationsService: NotificationsService,
  ) {}

  @Cron(CronExpression.EVERY_HOUR)
  async sendAppointmentReminders() {
    const now = new Date();
    const oneHourFromNow = new Date(now.getTime() + 60 * 60 * 1000);
    const twoHoursFromNow = new Date(now.getTime() + 2 * 60 * 60 * 1000);

    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯ ÙÙŠ Ø§Ù„Ø³Ø§Ø¹Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©
    const upcomingAppointments = await this.prisma.appointment.findMany({
      where: {
        appointmentDate: {
          gte: oneHourFromNow,
          lte: twoHoursFromNow,
        },
        status: 'CONFIRMED',
      },
      include: {
        patient: {
          include: { profile: true },
        },
        doctor: {
          include: { profile: true },
        },
      },
    });

    for (const appointment of upcomingAppointments) {
      await this.notificationsService.sendNotification(appointment.patientId, {
        title: 'ØªØ°ÙƒÙŠØ± Ø¨Ø§Ù„Ù…ÙˆØ¹Ø¯',
        message: `Ù…ÙˆØ¹Ø¯Ùƒ Ù…Ø¹ Ø¯. ${appointment.doctor.profile.firstName} Ø³ÙŠØ¨Ø¯Ø£ Ø®Ù„Ø§Ù„ Ø³Ø§Ø¹Ø©`,
        type: 'APPOINTMENT',
      });
    }
  }

  @Cron(CronExpression.EVERY_DAY_AT_8AM)
  async sendDailyAppointmentSummary() {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const todaysAppointments = await this.prisma.appointment.findMany({
      where: {
        appointmentDate: {
          gte: today,
          lt: tomorrow,
        },
      },
      include: {
        patient: {
          include: { profile: true },
        },
        doctor: {
          include: { profile: true },
        },
      },
    });

    // Ø¥Ø±Ø³Ø§Ù„ Ù…Ù„Ø®Øµ Ù„Ù„Ù…Ø±Ø¶Ù‰
    for (const appointment of todaysAppointments) {
      await this.notificationsService.sendNotification(appointment.patientId, {
        title: 'Ù…Ù„Ø®Øµ Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø§Ù„ÙŠÙˆÙ…',
        message: `Ù„Ø¯ÙŠÙƒ Ù…ÙˆØ¹Ø¯ Ù…Ø¹ Ø¯. ${appointment.doctor.profile.firstName} ÙÙŠ ${appointment.appointmentTime.toLocaleTimeString()}`,
        type: 'APPOINTMENT',
      });
    }
  }
}
```

### **Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø±Ø§Ø¨Ø¹: Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ÙˆØªØ­Ø³ÙŠÙ†Ø§Øª**

#### **4.1 Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª**
```typescript
// test/unit/payments.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { PaymentsService } from '../../src/modules/payments/payments.service';
import { PrismaService } from '../../src/database/prisma.service';
import { StripeService } from '../../src/modules/stripe/stripe.service';

describe('PaymentsService', () => {
  let service: PaymentsService;
  let prismaService: PrismaService;
  let stripeService: StripeService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        PaymentsService,
        {
          provide: PrismaService,
          useValue: {
            payment: {
              create: jest.fn(),
              findUnique: jest.fn(),
              update: jest.fn(),
              findMany: jest.fn(),
            },
          },
        },
        {
          provide: StripeService,
          useValue: {
            createPaymentIntent: jest.fn(),
            confirmPaymentIntent: jest.fn(),
            createRefund: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get<PaymentsService>(PaymentsService);
    prismaService = module.get<PrismaService>(PrismaService);
    stripeService = module.get<StripeService>(StripeService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should create a payment', async () => {
    const createPaymentDto = {
      appointmentId: 1,
      amount: 100,
      currency: 'USD',
      paymentMethod: 'CARD',
    };

    const expectedResult = { id: 1, ...createPaymentDto };
    jest.spyOn(prismaService.payment, 'create').mockResolvedValue(expectedResult);
    jest.spyOn(stripeService, 'createPaymentIntent').mockResolvedValue({ id: 'pi_123' });

    const result = await service.createPayment(createPaymentDto);
    expect(result).toEqual(expectedResult);
  });

  it('should confirm a payment', async () => {
    const payment = { id: 1, transactionId: 'pi_123', status: 'PENDING' };
    jest.spyOn(prismaService.payment, 'findUnique').mockResolvedValue(payment);
    jest.spyOn(stripeService, 'confirmPaymentIntent').mockResolvedValue({});
    jest.spyOn(prismaService.payment, 'update').mockResolvedValue({ ...payment, status: 'COMPLETED' });

    const result = await service.confirmPayment(1);
    expect(result.status).toBe('COMPLETED');
  });
});
```

#### **4.2 Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª**
```typescript
// test/unit/notifications.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { NotificationsService } from '../../src/modules/notifications/notifications.service';
import { PrismaService } from '../../src/database/prisma.service';
import { FirebaseService } from '../../src/modules/firebase/firebase.service';
import { EmailService } from '../../src/modules/email/email.service';

describe('NotificationsService', () => {
  let service: NotificationsService;
  let prismaService: PrismaService;
  let firebaseService: FirebaseService;
  let emailService: EmailService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        NotificationsService,
        {
          provide: PrismaService,
          useValue: {
            notification: {
              create: jest.fn(),
              findMany: jest.fn(),
              update: jest.fn(),
            },
            notificationSettings: {
              findUnique: jest.fn(),
              upsert: jest.fn(),
            },
          },
        },
        {
          provide: FirebaseService,
          useValue: {
            sendNotification: jest.fn(),
          },
        },
        {
          provide: EmailService,
          useValue: {
            sendEmail: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get<NotificationsService>(NotificationsService);
    prismaService = module.get<PrismaService>(PrismaService);
    firebaseService = module.get<FirebaseService>(FirebaseService);
    emailService = module.get<EmailService>(EmailService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should send a notification', async () => {
    const notification = {
      title: 'Test Notification',
      message: 'Test message',
      type: 'SYSTEM',
    };

    const expectedResult = { id: 1, userId: 1, ...notification };
    jest.spyOn(prismaService.notification, 'create').mockResolvedValue(expectedResult);
    jest.spyOn(firebaseService, 'sendNotification').mockResolvedValue({});

    const result = await service.sendNotification(1, notification);
    expect(result).toEqual(expectedResult);
  });
});
```

---

## ğŸ”§ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©

### **Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø© Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ©**
```env
# Stripe
STRIPE_SECRET_KEY=sk_test_your_stripe_secret_key
STRIPE_PUBLISHABLE_KEY=pk_test_your_stripe_publishable_key
STRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret

# Firebase
FIREBASE_PROJECT_ID=your_project_id
FIREBASE_PRIVATE_KEY=your_private_key
FIREBASE_CLIENT_EMAIL=your_client_email

# Email
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your_email@gmail.com
SMTP_PASS=your_app_password

# SMS
TWILIO_ACCOUNT_SID=your_twilio_account_sid
TWILIO_AUTH_TOKEN=your_twilio_auth_token
TWILIO_PHONE_NUMBER=your_twilio_phone_number

# Background Jobs
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
```

---

## ğŸ“Š Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ù†Ø¬Ø§Ø­

### **Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**
1. âœ… Ù†Ø¸Ø§Ù… Ù…Ø¯ÙÙˆØ¹Ø§Øª Ù…ØªÙƒØ§Ù…Ù„ Ù…Ø¹ Stripe
2. âœ… Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Firebase ØªØ¹Ù…Ù„
3. âœ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„Ø§Øª ÙŠØ¹Ù…Ù„
4. âœ… Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„Ø© ØªØ¹Ù…Ù„
5. âœ… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª ØªØ¹Ù…Ù„
6. âœ… Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø´Ø§Ù…Ù„Ø© ØªØ¹Ù…Ù„

### **Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**
- [ ] Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¯ÙØ¹
- [ ] ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹
- [ ] Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª
- [ ] Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
- [ ] Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„Ø©
- [ ] Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª

---

## ğŸš€ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©

Ø¨Ø¹Ø¯ Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø±Ø§Ø¨Ø¹Ø©ØŒ Ø³ØªÙƒÙˆÙ† Ø¬Ø§Ù‡Ø²Ø§Ù‹ Ù„Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰:
- **Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø®Ø§Ù…Ø³Ø©:** Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª ÙˆØ§Ù„ØªÙ‚Ø§Ø±ÙŠØ±
- **Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø³Ø§Ø¯Ø³Ø©:** Ø§Ù„Ù†Ø´Ø± ÙˆØ§Ù„Ø¥Ù†ØªØ§Ø¬

---

*Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø© ØªØ¶ÙŠÙ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø§Ù„ÙŠØ© Ù„Ù„Ù†Ø¸Ø§Ù… Ù…Ø¹ Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª ÙˆØ§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„Ø°ÙƒÙŠØ©*
