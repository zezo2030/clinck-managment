# ğŸ“… Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©: Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯ - Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¹ÙŠØ§Ø¯Ø§Øª

## ğŸ“‹ Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©

Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø© ØªØ±ÙƒØ² Ø¹Ù„Ù‰ ØªØ·ÙˆÙŠØ± Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø§Ù„Ø´Ø§Ù…Ù„ Ù…Ø¹ Ø¯Ø¹Ù… Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± ÙˆØ§Ù„Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„Ø°ÙƒÙŠØ©.

**Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ù…Ù‚Ø¯Ø±Ø©:** 4 Ø£Ø³Ø§Ø¨ÙŠØ¹  
**Ø§Ù„Ù‡Ø¯Ù:** ØªØ·ÙˆÙŠØ± Ù†Ø¸Ø§Ù… Ù…ÙˆØ§Ø¹ÙŠØ¯ Ù…ØªÙƒØ§Ù…Ù„ Ù…Ø¹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù†ØªØ¸Ø§Ø± Ø°ÙƒÙŠØ©

---

## ğŸ› ï¸ Ø§Ù„ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©

### **Core Framework:**
- **NestJS** - Ø¥Ø·Ø§Ø± Ø¹Ù…Ù„ Node.js Ù…ØªÙ‚Ø¯Ù…
- **TypeScript** - Ù„ØºØ© Ø§Ù„Ø¨Ø±Ù…Ø¬Ø©
- **Node.js** - Ø¨ÙŠØ¦Ø© Ø§Ù„ØªØ´ØºÙŠÙ„

### **Database:**
- **PostgreSQL** - Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
- **Prisma** - ORM Ù„Ø¥Ø¯Ø§Ø±Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
- **Redis** - ØªØ®Ø²ÙŠÙ† Ù…Ø¤Ù‚Øª Ù„Ù„Ø£ÙˆÙ‚Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©

### **Real-time Communication:**
- **Socket.io** - Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø± Ù„Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
- **WebSockets** - Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±

### **External Services:**
- **SendGrid** - Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„Ø§Øª
- **Twilio** - Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†ØµÙŠØ©

---

## ğŸ—ï¸ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ù„Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©

```
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ modules/
â”‚   â”‚   â”œâ”€â”€ appointments/       # ÙˆØ­Ø¯Ø© Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯
â”‚   â”‚   â”‚   â”œâ”€â”€ appointments.controller.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ appointments.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ appointments.module.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ create-appointment.dto.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ update-appointment.dto.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ appointment-query.dto.ts
â”‚   â”‚   â”‚   â””â”€â”€ entities/
â”‚   â”‚   â”‚       â””â”€â”€ appointment.entity.ts
â”‚   â”‚   â”œâ”€â”€ doctors/            # ÙˆØ­Ø¯Ø© Ø§Ù„Ø£Ø·Ø¨Ø§Ø¡
â”‚   â”‚   â”‚   â”œâ”€â”€ doctors.controller.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ doctors.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ doctors.module.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â””â”€â”€ entities/
â”‚   â”‚   â”œâ”€â”€ clinics/           # ÙˆØ­Ø¯Ø© Ø§Ù„Ø¹ÙŠØ§Ø¯Ø§Øª
â”‚   â”‚   â”‚   â”œâ”€â”€ clinics.controller.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ clinics.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ clinics.module.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â””â”€â”€ entities/
â”‚   â”‚   â”œâ”€â”€ departments/        # ÙˆØ­Ø¯Ø© Ø§Ù„Ø£Ù‚Ø³Ø§Ù…
â”‚   â”‚   â”‚   â”œâ”€â”€ departments.controller.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ departments.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ departments.module.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â””â”€â”€ entities/
â”‚   â”‚   â””â”€â”€ waiting-list/      # ÙˆØ­Ø¯Ø© Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
â”‚   â”‚       â”œâ”€â”€ waiting-list.controller.ts
â”‚   â”‚       â”œâ”€â”€ waiting-list.service.ts
â”‚   â”‚       â”œâ”€â”€ waiting-list.module.ts
â”‚   â”‚       â”œâ”€â”€ dto/
â”‚   â”‚       â””â”€â”€ entities/
â”‚   â”œâ”€â”€ common/
â”‚   â”‚   â”œâ”€â”€ schedulers/         # Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„Ø©
â”‚   â”‚   â”‚   â”œâ”€â”€ appointment-reminder.scheduler.ts
â”‚   â”‚   â”‚   â””â”€â”€ waiting-list.scheduler.ts
â”‚   â”‚   â””â”€â”€ utils/
â”‚   â”‚       â”œâ”€â”€ date.util.ts
â”‚   â”‚       â””â”€â”€ notification.util.ts
â”‚   â””â”€â”€ config/
â”‚       â”œâ”€â”€ redis.config.ts
â”‚       â””â”€â”€ email.config.ts
```

---

## ğŸ—„ï¸ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª - Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©

### **Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©**

```prisma
// Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø¹ÙŠØ§Ø¯Ø§Øª
model Clinic {
  id          Int      @id @default(autoincrement())
  name        String
  address     String
  phone       String
  email       String
  workingHours Json
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  departments   Department[]
  appointments  Appointment[]
  doctors       Doctor[]

  @@map("clinics")
}

// Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø£Ù‚Ø³Ø§Ù…
model Department {
  id          Int      @id @default(autoincrement())
  clinicId    Int
  name        String
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  clinic       Clinic    @relation(fields: [clinicId], references: [id])
  doctors      Doctor[]
  appointments Appointment[]

  @@map("departments")
}

// Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø£Ø·Ø¨Ø§Ø¡
model Doctor {
  id           Int      @id @default(autoincrement())
  userId       Int      @unique
  clinicId     Int
  departmentId Int
  specialization String
  licenseNumber String
  experience   Int
  consultationFee Decimal @db.Decimal(10, 2)
  isAvailable  Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  user         User         @relation(fields: [userId], references: [id])
  clinic       Clinic       @relation(fields: [clinicId], references: [id])
  department   Department   @relation(fields: [departmentId], references: [id])
  appointments Appointment[]
  schedules    Schedule[]
  ratings      Rating[]

  @@map("doctors")
}

// Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯
model Appointment {
  id            Int            @id @default(autoincrement())
  patientId     Int
  doctorId      Int
  clinicId      Int
  departmentId  Int
  appointmentDate DateTime
  appointmentTime DateTime
  status        AppointmentStatus @default(SCHEDULED)
  reason        String?
  notes         String?
  isEmergency   Boolean        @default(false)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  patient       User           @relation("PatientAppointments", fields: [patientId], references: [id])
  doctor        User           @relation("DoctorAppointments", fields: [doctorId], references: [id])
  clinic        Clinic         @relation(fields: [clinicId], references: [id])
  department    Department     @relation(fields: [departmentId], references: [id])

  @@map("appointments")
}

// Ø¬Ø¯ÙˆÙ„ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
model WaitingList {
  id           Int      @id @default(autoincrement())
  patientId    Int
  doctorId     Int
  departmentId Int
  priority     Int      @default(1)
  notified     Boolean  @default(false)
  createdAt    DateTime @default(now())

  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  patient    User       @relation(fields: [patientId], references: [id])
  doctor     User       @relation(fields: [doctorId], references: [id])
  department Department @relation(fields: [departmentId], references: [id])

  @@map("waiting_list")
}

// Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠØ©
model Schedule {
  id        Int      @id @default(autoincrement())
  doctorId  Int
  dayOfWeek Int      // 0-6 (Ø§Ù„Ø£Ø­Ø¯-Ø§Ù„Ø³Ø¨Øª)
  startTime DateTime
  endTime   DateTime
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())

  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  doctor Doctor @relation(fields: [doctorId], references: [id])

  @@map("schedules")
}

// Enums
enum AppointmentStatus {
  SCHEDULED
  CONFIRMED
  CANCELLED
  COMPLETED
  NO_SHOW
}
```

---

## ğŸš€ Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªÙ†ÙÙŠØ°

### **Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø£ÙˆÙ„: ÙˆØ­Ø¯Ø© Ø§Ù„Ø£Ø·Ø¨Ø§Ø¡ ÙˆØ§Ù„Ø¹ÙŠØ§Ø¯Ø§Øª**

#### **1.1 ÙˆØ­Ø¯Ø© Ø§Ù„Ø£Ø·Ø¨Ø§Ø¡**
```typescript
// src/modules/doctors/doctors.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../database/prisma.service';
import { CreateDoctorDto } from './dto/create-doctor.dto';

@Injectable()
export class DoctorsService {
  constructor(private prisma: PrismaService) {}

  async create(createDoctorDto: CreateDoctorDto) {
    return this.prisma.doctor.create({
      data: createDoctorDto,
      include: {
        user: {
          include: { profile: true },
        },
        clinic: true,
        department: true,
        schedules: true,
      },
    });
  }

  async findAll(query: any) {
    const { clinicId, departmentId, specialization, isAvailable } = query;
    
    return this.prisma.doctor.findMany({
      where: {
        ...(clinicId && { clinicId: parseInt(clinicId) }),
        ...(departmentId && { departmentId: parseInt(departmentId) }),
        ...(specialization && { specialization: { contains: specialization } }),
        ...(isAvailable !== undefined && { isAvailable: isAvailable === 'true' }),
      },
      include: {
        user: {
          include: { profile: true },
        },
        clinic: true,
        department: true,
        schedules: true,
      },
    });
  }

  async findOne(id: number) {
    return this.prisma.doctor.findUnique({
      where: { id },
      include: {
        user: {
          include: { profile: true },
        },
        clinic: true,
        department: true,
        schedules: true,
        appointments: {
          include: {
            patient: {
              include: { profile: true },
            },
          },
        },
      },
    });
  }

  async update(id: number, updateDoctorDto: any) {
    return this.prisma.doctor.update({
      where: { id },
      data: updateDoctorDto,
      include: {
        user: {
          include: { profile: true },
        },
        clinic: true,
        department: true,
        schedules: true,
      },
    });
  }

  async setAvailability(id: number, isAvailable: boolean) {
    return this.prisma.doctor.update({
      where: { id },
      data: { isAvailable },
    });
  }
}
```

#### **1.2 ÙˆØ­Ø¯Ø© Ø§Ù„Ø¹ÙŠØ§Ø¯Ø§Øª**
```typescript
// src/modules/clinics/clinics.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../database/prisma.service';
import { CreateClinicDto } from './dto/create-clinic.dto';

@Injectable()
export class ClinicsService {
  constructor(private prisma: PrismaService) {}

  async create(createClinicDto: CreateClinicDto) {
    return this.prisma.clinic.create({
      data: createClinicDto,
      include: {
        departments: true,
        doctors: {
          include: {
            user: {
              include: { profile: true },
            },
          },
        },
      },
    });
  }

  async findAll() {
    return this.prisma.clinic.findMany({
      include: {
        departments: true,
        doctors: {
          include: {
            user: {
              include: { profile: true },
            },
          },
        },
      },
    });
  }

  async findOne(id: number) {
    return this.prisma.clinic.findUnique({
      where: { id },
      include: {
        departments: true,
        doctors: {
          include: {
            user: {
              include: { profile: true },
            },
            schedules: true,
          },
        },
        appointments: {
          include: {
            patient: {
              include: { profile: true },
            },
            doctor: {
              include: { profile: true },
            },
          },
        },
      },
    });
  }

  async update(id: number, updateClinicDto: any) {
    return this.prisma.clinic.update({
      where: { id },
      data: updateClinicDto,
      include: {
        departments: true,
        doctors: {
          include: {
            user: {
              include: { profile: true },
            },
          },
        },
      },
    });
  }
}
```

### **Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø«Ø§Ù†ÙŠ: ÙˆØ­Ø¯Ø© Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯**

#### **2.1 ÙˆØ­Ø¯Ø© Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©**
```typescript
// src/modules/appointments/appointments.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../database/prisma.service';
import { CreateAppointmentDto } from './dto/create-appointment.dto';

@Injectable()
export class AppointmentsService {
  constructor(private prisma: PrismaService) {}

  async create(createAppointmentDto: CreateAppointmentDto) {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙˆÙØ± Ø§Ù„Ù…ÙˆØ¹Ø¯
    const isAvailable = await this.checkAvailability(
      createAppointmentDto.doctorId,
      createAppointmentDto.appointmentDate,
      createAppointmentDto.appointmentTime,
    );

    if (!isAvailable) {
      throw new Error('Ø§Ù„Ù…ÙˆØ¹Ø¯ ØºÙŠØ± Ù…ØªØ§Ø­');
    }

    return this.prisma.appointment.create({
      data: createAppointmentDto,
      include: {
        patient: {
          include: { profile: true },
        },
        doctor: {
          include: { profile: true },
        },
        clinic: true,
        department: true,
      },
    });
  }

  async findAll(query: any) {
    const { page = 1, limit = 10, status, doctorId, patientId, clinicId } = query;
    
    return this.prisma.appointment.findMany({
      where: {
        ...(status && { status }),
        ...(doctorId && { doctorId: parseInt(doctorId) }),
        ...(patientId && { patientId: parseInt(patientId) }),
        ...(clinicId && { clinicId: parseInt(clinicId) }),
      },
      include: {
        patient: {
          include: { profile: true },
        },
        doctor: {
          include: { profile: true },
        },
        clinic: true,
        department: true,
      },
      skip: (page - 1) * limit,
      take: parseInt(limit),
      orderBy: { appointmentDate: 'asc' },
    });
  }

  async findOne(id: number) {
    return this.prisma.appointment.findUnique({
      where: { id },
      include: {
        patient: {
          include: { profile: true },
        },
        doctor: {
          include: { profile: true },
        },
        clinic: true,
        department: true,
      },
    });
  }

  async update(id: number, updateAppointmentDto: any) {
    return this.prisma.appointment.update({
      where: { id },
      data: updateAppointmentDto,
      include: {
        patient: {
          include: { profile: true },
        },
        doctor: {
          include: { profile: true },
        },
        clinic: true,
        department: true,
      },
    });
  }

  async cancel(id: number, reason?: string) {
    return this.prisma.appointment.update({
      where: { id },
      data: {
        status: 'CANCELLED',
        notes: reason,
      },
    });
  }

  async confirm(id: number) {
    return this.prisma.appointment.update({
      where: { id },
      data: {
        status: 'CONFIRMED',
      },
    });
  }

  async complete(id: number) {
    return this.prisma.appointment.update({
      where: { id },
      data: {
        status: 'COMPLETED',
      },
    });
  }
}
```

#### **2.2 ÙØ­Øµ ØªÙˆÙØ± Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯**
```typescript
// src/modules/appointments/appointments.service.ts (Ø§Ø³ØªÙƒÙ…Ø§Ù„)

async checkAvailability(doctorId: number, date: Date, time: Date) {
  const existingAppointment = await this.prisma.appointment.findFirst({
    where: {
      doctorId,
      appointmentDate: date,
      appointmentTime: time,
      status: {
        in: ['SCHEDULED', 'CONFIRMED'],
      },
    },
  });

  return !existingAppointment;
}

async getAvailableSlots(doctorId: number, date: Date) {
  // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø·Ø¨ÙŠØ¨
  const doctor = await this.prisma.doctor.findUnique({
    where: { id: doctorId },
    include: { schedules: true },
  });

  if (!doctor) {
    throw new Error('Ø§Ù„Ø·Ø¨ÙŠØ¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
  }

  const dayOfWeek = date.getDay();
  const schedule = doctor.schedules.find(s => s.dayOfWeek === dayOfWeek);

  if (!schedule) {
    return [];
  }

  // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø§Ù„Ù…Ø­Ø¬ÙˆØ²Ø©
  const bookedAppointments = await this.prisma.appointment.findMany({
    where: {
      doctorId,
      appointmentDate: date,
      status: {
        in: ['SCHEDULED', 'CONFIRMED'],
      },
    },
  });

  // Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ÙˆÙ‚Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©
  const availableSlots = [];
  const startTime = new Date(date);
  startTime.setHours(schedule.startTime.getHours(), schedule.startTime.getMinutes());
  
  const endTime = new Date(date);
  endTime.setHours(schedule.endTime.getHours(), schedule.endTime.getMinutes());

  const slotDuration = 30; // 30 Ø¯Ù‚ÙŠÙ‚Ø© Ù„ÙƒÙ„ Ù…ÙˆØ¹Ø¯

  while (startTime < endTime) {
    const slotTime = new Date(startTime);
    const isBooked = bookedAppointments.some(appointment => 
      appointment.appointmentTime.getTime() === slotTime.getTime()
    );

    if (!isBooked) {
      availableSlots.push(new Date(slotTime));
    }

    startTime.setMinutes(startTime.getMinutes() + slotDuration);
  }

  return availableSlots;
}
```

### **Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø«Ø§Ù„Ø«: Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±**

#### **3.1 ÙˆØ­Ø¯Ø© Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±**
```typescript
// src/modules/waiting-list/waiting-list.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../database/prisma.service';

@Injectable()
export class WaitingListService {
  constructor(private prisma: PrismaService) {}

  async addToWaitingList(patientId: number, doctorId: number, departmentId: number) {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ø±ÙŠØ¶ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
    const existingEntry = await this.prisma.waitingList.findFirst({
      where: {
        patientId,
        doctorId,
      },
    });

    if (existingEntry) {
      throw new Error('Ø§Ù„Ù…Ø±ÙŠØ¶ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±');
    }

    return this.prisma.waitingList.create({
      data: {
        patientId,
        doctorId,
        departmentId,
        priority: 1,
      },
      include: {
        patient: {
          include: { profile: true },
        },
        doctor: {
          include: { profile: true },
        },
        department: true,
      },
    });
  }

  async getWaitingList(doctorId?: number) {
    return this.prisma.waitingList.findMany({
      where: doctorId ? { doctorId } : {},
      include: {
        patient: {
          include: { profile: true },
        },
        doctor: {
          include: { profile: true },
        },
        department: true,
      },
      orderBy: [
        { priority: 'desc' },
        { createdAt: 'asc' },
      ],
    });
  }

  async notifyNextInLine(doctorId: number, availableDate: Date, availableTime: Date) {
    const nextInLine = await this.prisma.waitingList.findFirst({
      where: {
        doctorId,
        notified: false,
      },
      include: {
        patient: {
          include: { profile: true },
        },
      },
      orderBy: [
        { priority: 'desc' },
        { createdAt: 'asc' },
      ],
    });

    if (nextInLine) {
      // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ù…Ø±ÙŠØ¶
      await this.sendNotification(nextInLine.patientId, {
        title: 'Ù…ÙˆØ¹Ø¯ Ù…ØªØ§Ø­',
        message: `Ù…ÙˆØ¹Ø¯ Ù…ØªØ§Ø­ Ù…Ø¹ Ø§Ù„Ø·Ø¨ÙŠØ¨ ÙÙŠ ${availableDate.toLocaleDateString()} Ø§Ù„Ø³Ø§Ø¹Ø© ${availableTime.toLocaleTimeString()}`,
        type: 'APPOINTMENT',
      });

      // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±
      await this.prisma.waitingList.update({
        where: { id: nextInLine.id },
        data: { notified: true },
      });
    }

    return nextInLine;
  }

  async removeFromWaitingList(id: number) {
    return this.prisma.waitingList.delete({
      where: { id },
    });
  }

  async updatePriority(id: number, priority: number) {
    return this.prisma.waitingList.update({
      where: { id },
      data: { priority },
    });
  }

  private async sendNotification(userId: number, notification: any) {
    // Ù…Ù†Ø·Ù‚ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
    // Ø³ÙŠØªÙ… ØªØ·ÙˆÙŠØ±Ù‡ ÙÙŠ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø±Ø§Ø¨Ø¹Ø©
  }
}
```

#### **3.2 Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠØ©**
```typescript
// src/modules/doctors/schedules.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../database/prisma.service';

@Injectable()
export class SchedulesService {
  constructor(private prisma: PrismaService) {}

  async createSchedule(doctorId: number, scheduleData: any) {
    return this.prisma.schedule.create({
      data: {
        doctorId,
        ...scheduleData,
      },
    });
  }

  async getDoctorSchedule(doctorId: number) {
    return this.prisma.schedule.findMany({
      where: {
        doctorId,
        isActive: true,
      },
      orderBy: { dayOfWeek: 'asc' },
    });
  }

  async updateSchedule(scheduleId: number, updateData: any) {
    return this.prisma.schedule.update({
      where: { id: scheduleId },
      data: updateData,
    });
  }

  async deleteSchedule(scheduleId: number) {
    return this.prisma.schedule.delete({
      where: { id: scheduleId },
    });
  }

  async getAvailableDoctors(date: Date, departmentId?: number) {
    const dayOfWeek = date.getDay();
    
    return this.prisma.doctor.findMany({
      where: {
        isAvailable: true,
        ...(departmentId && { departmentId }),
        schedules: {
          some: {
            dayOfWeek,
            isActive: true,
          },
        },
      },
      include: {
        user: {
          include: { profile: true },
        },
        department: true,
        schedules: {
          where: {
            dayOfWeek,
            isActive: true,
          },
        },
      },
    });
  }
}
```

### **Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø±Ø§Ø¨Ø¹: Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ÙˆØ§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª**

#### **4.1 Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯**
```typescript
// test/unit/appointments.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AppointmentsService } from '../../src/modules/appointments/appointments.service';
import { PrismaService } from '../../src/database/prisma.service';

describe('AppointmentsService', () => {
  let service: AppointmentsService;
  let prismaService: PrismaService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AppointmentsService,
        {
          provide: PrismaService,
          useValue: {
            appointment: {
              create: jest.fn(),
              findMany: jest.fn(),
              findUnique: jest.fn(),
              update: jest.fn(),
              findFirst: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    service = module.get<AppointmentsService>(AppointmentsService);
    prismaService = module.get<PrismaService>(PrismaService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should create an appointment', async () => {
    const createAppointmentDto = {
      patientId: 1,
      doctorId: 2,
      clinicId: 1,
      departmentId: 1,
      appointmentDate: new Date(),
      appointmentTime: new Date(),
    };

    const expectedResult = { id: 1, ...createAppointmentDto };
    jest.spyOn(prismaService.appointment, 'create').mockResolvedValue(expectedResult);
    jest.spyOn(service, 'checkAvailability').mockResolvedValue(true);

    const result = await service.create(createAppointmentDto);
    expect(result).toEqual(expectedResult);
  });

  it('should check availability correctly', async () => {
    jest.spyOn(prismaService.appointment, 'findFirst').mockResolvedValue(null);
    
    const result = await service.checkAvailability(1, new Date(), new Date());
    expect(result).toBe(true);
  });
});
```

#### **4.2 Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„ØªÙƒØ§Ù…Ù„**
```typescript
// test/integration/appointments.e2e-spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from '../../src/app.module';

describe('Appointments (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/appointments (POST)', () => {
    return request(app.getHttpServer())
      .post('/appointments')
      .send({
        patientId: 1,
        doctorId: 2,
        clinicId: 1,
        departmentId: 1,
        appointmentDate: '2024-01-15',
        appointmentTime: '10:00:00',
      })
      .expect(201);
  });

  it('/appointments (GET)', () => {
    return request(app.getHttpServer())
      .get('/appointments')
      .expect(200);
  });

  it('/appointments/:id/cancel (PATCH)', () => {
    return request(app.getHttpServer())
      .patch('/appointments/1/cancel')
      .send({ reason: 'Patient request' })
      .expect(200);
  });
});
```

---

## ğŸ”§ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©

### **Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø© Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ©**
```env
# Redis
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=

# Email
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your_email@gmail.com
SMTP_PASS=your_app_password

# SMS
TWILIO_ACCOUNT_SID=your_twilio_account_sid
TWILIO_AUTH_TOKEN=your_twilio_auth_token
TWILIO_PHONE_NUMBER=your_twilio_phone_number
```

---

## ğŸ“Š Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ù†Ø¬Ø§Ø­

### **Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**
1. âœ… Ù†Ø¸Ø§Ù… Ù…ÙˆØ§Ø¹ÙŠØ¯ Ù…ØªÙƒØ§Ù…Ù„ ÙŠØ¹Ù…Ù„
2. âœ… Ù‚Ø§Ø¦Ù…Ø© Ø§Ù†ØªØ¸Ø§Ø± Ø°ÙƒÙŠØ© ØªØ¹Ù…Ù„
3. âœ… ÙØ­Øµ ØªÙˆÙØ± Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯ ÙŠØ¹Ù…Ù„
4. âœ… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠØ© ØªØ¹Ù…Ù„
5. âœ… Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯ ØªØ¹Ù…Ù„
6. âœ… Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø´Ø§Ù…Ù„Ø© ØªØ¹Ù…Ù„

### **Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**
- [ ] Ø­Ø¬Ø² Ù…ÙˆØ¹Ø¯ Ø¬Ø¯ÙŠØ¯
- [ ] Ø¥Ù„ØºØ§Ø¡ Ù…ÙˆØ¹Ø¯
- [ ] ØªØ£ÙƒÙŠØ¯ Ù…ÙˆØ¹Ø¯
- [ ] Ø¥Ø¶Ø§ÙØ© Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
- [ ] Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯
- [ ] ÙØ­Øµ Ø§Ù„Ø£ÙˆÙ‚Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©

---

## ğŸš€ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©

Ø¨Ø¹Ø¯ Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©ØŒ Ø³ØªÙƒÙˆÙ† Ø¬Ø§Ù‡Ø²Ø§Ù‹ Ù„Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰:
- **Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø©:** Ø§Ù„Ø§Ø³ØªØ´Ø§Ø±Ø§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
- **Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø±Ø§Ø¨Ø¹Ø©:** Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª ÙˆØ§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
- **Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø®Ø§Ù…Ø³Ø©:** Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª ÙˆØ§Ù„ØªÙ‚Ø§Ø±ÙŠØ±

---

*Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø© ØªØ´ÙƒÙ„ Ø§Ù„Ø¹Ù…ÙˆØ¯ Ø§Ù„ÙÙ‚Ø±ÙŠ Ù„Ù„Ù†Ø¸Ø§Ù… ÙˆØªØ¶Ù…Ù† Ø¥Ø¯Ø§Ø±Ø© ÙØ¹Ø§Ù„Ø© Ù„Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯*
