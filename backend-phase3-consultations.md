# ğŸ’¬ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø©: Ø§Ù„Ø§Ø³ØªØ´Ø§Ø±Ø§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© - Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¹ÙŠØ§Ø¯Ø§Øª

## ğŸ“‹ Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø©

Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø© ØªØ±ÙƒØ² Ø¹Ù„Ù‰ ØªØ·ÙˆÙŠØ± Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ø³ØªØ´Ø§Ø±Ø§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù…Ø¹ Ø¯Ø¹Ù… Ù…ÙƒØ§Ù„Ù…Ø§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ÙˆØ§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©.

**Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ù…Ù‚Ø¯Ø±Ø©:** 4 Ø£Ø³Ø§Ø¨ÙŠØ¹  
**Ø§Ù„Ù‡Ø¯Ù:** ØªØ·ÙˆÙŠØ± Ù†Ø¸Ø§Ù… Ø§Ø³ØªØ´Ø§Ø±Ø§Øª Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù…ØªÙƒØ§Ù…Ù„ Ù…Ø¹ Ù…ÙƒØ§Ù„Ù…Ø§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ

---

## ğŸ› ï¸ Ø§Ù„ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©

### **Core Framework:**
- **NestJS** - Ø¥Ø·Ø§Ø± Ø¹Ù…Ù„ Node.js Ù…ØªÙ‚Ø¯Ù…
- **TypeScript** - Ù„ØºØ© Ø§Ù„Ø¨Ø±Ù…Ø¬Ø©
- **Node.js** - Ø¨ÙŠØ¦Ø© Ø§Ù„ØªØ´ØºÙŠÙ„

### **Database:**
- **PostgreSQL** - Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
- **Prisma** - ORM Ù„Ø¥Ø¯Ø§Ø±Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
- **Redis** - ØªØ®Ø²ÙŠÙ† Ù…Ø¤Ù‚Øª Ù„Ù„Ø±Ø³Ø§Ø¦Ù„

### **Real-time Communication:**
- **Socket.io** - Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
- **WebSockets** - Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
- **Agora SDK** - Ù…ÙƒØ§Ù„Ù…Ø§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ

### **File Storage:**
- **AWS S3** - ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ù„ÙØ§Øª
- **Multer** - Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª

---

## ğŸ—ï¸ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ù„Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø©

```
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ modules/
â”‚   â”‚   â”œâ”€â”€ consultations/     # ÙˆØ­Ø¯Ø© Ø§Ù„Ø§Ø³ØªØ´Ø§Ø±Ø§Øª
â”‚   â”‚   â”‚   â”œâ”€â”€ consultations.controller.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ consultations.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ consultations.module.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ create-consultation.dto.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ start-consultation.dto.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ end-consultation.dto.ts
â”‚   â”‚   â”‚   â””â”€â”€ entities/
â”‚   â”‚   â”‚       â””â”€â”€ consultation.entity.ts
â”‚   â”‚   â”œâ”€â”€ messages/          # ÙˆØ­Ø¯Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
â”‚   â”‚   â”‚   â”œâ”€â”€ messages.controller.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ messages.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ messages.module.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â””â”€â”€ entities/
â”‚   â”‚   â”œâ”€â”€ agora/             # ÙˆØ­Ø¯Ø© Agora
â”‚   â”‚   â”‚   â”œâ”€â”€ agora.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ agora.controller.ts
â”‚   â”‚   â”‚   â””â”€â”€ agora.module.ts
â”‚   â”‚   â””â”€â”€ file-upload/       # ÙˆØ­Ø¯Ø© Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª
â”‚   â”‚       â”œâ”€â”€ file-upload.service.ts
â”‚   â”‚       â”œâ”€â”€ file-upload.controller.ts
â”‚   â”‚       â””â”€â”€ file-upload.module.ts
â”‚   â”œâ”€â”€ common/
â”‚   â”‚   â”œâ”€â”€ gateways/          # WebSocket Gateways
â”‚   â”‚   â”‚   â”œâ”€â”€ consultation.gateway.ts
â”‚   â”‚   â”‚   â””â”€â”€ message.gateway.ts
â”‚   â”‚   â””â”€â”€ utils/
â”‚   â”‚       â”œâ”€â”€ agora.util.ts
â”‚   â”‚       â””â”€â”€ file.util.ts
â”‚   â””â”€â”€ config/
â”‚       â”œâ”€â”€ agora.config.ts
â”‚       â””â”€â”€ aws.config.ts
```

---

## ğŸ—„ï¸ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª - Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø©

### **Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©**

```prisma
// Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø§Ø³ØªØ´Ø§Ø±Ø§Øª
model Consultation {
  id            Int              @id @default(autoincrement())
  appointmentId Int              @unique
  type          ConsultationType
  status        ConsultationStatus @default(SCHEDULED)
  startTime     DateTime?
  endTime       DateTime?
  duration      Int?             // Ø¨Ø§Ù„Ø¯Ù‚Ø§Ø¦Ù‚
  notes         String?
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  appointment Appointment @relation(fields: [appointmentId], references: [id])
  messages    Message[]

  @@map("consultations")
}

// Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
model Message {
  id             Int      @id @default(autoincrement())
  consultationId Int
  senderId       Int
  message        String
  messageType    MessageType @default(TEXT)
  fileUrl        String?
  createdAt      DateTime @default(now())

  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  consultation Consultation @relation(fields: [consultationId], references: [id])
  sender       User         @relation(fields: [senderId], references: [id])

  @@map("messages")
}

// Ø¬Ø¯ÙˆÙ„ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª
model Rating {
  id          Int      @id @default(autoincrement())
  appointmentId Int    @unique
  patientId   Int
  doctorId    Int
  rating      Int      // 1-5
  review      String?
  createdAt   DateTime @default(now())

  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  appointment Appointment @relation(fields: [appointmentId], references: [id])
  patient     User       @relation(fields: [patientId], references: [id])
  doctor      Doctor     @relation(fields: [doctorId], references: [id])

  @@map("ratings")
}

// Enums
enum ConsultationType {
  VIDEO
  CHAT
}

enum ConsultationStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum MessageType {
  TEXT
  IMAGE
  FILE
}
```

---

## ğŸš€ Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªÙ†ÙÙŠØ°

### **Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø£ÙˆÙ„: ÙˆØ­Ø¯Ø© Ø§Ù„Ø§Ø³ØªØ´Ø§Ø±Ø§Øª**

#### **1.1 ÙˆØ­Ø¯Ø© Ø§Ù„Ø§Ø³ØªØ´Ø§Ø±Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©**
```typescript
// src/modules/consultations/consultations.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../database/prisma.service';
import { CreateConsultationDto } from './dto/create-consultation.dto';

@Injectable()
export class ConsultationsService {
  constructor(private prisma: PrismaService) {}

  async create(createConsultationDto: CreateConsultationDto) {
    return this.prisma.consultation.create({
      data: createConsultationDto,
      include: {
        appointment: {
          include: {
            patient: {
              include: { profile: true },
            },
            doctor: {
              include: { profile: true },
            },
          },
        },
      },
    });
  }

  async startConsultation(consultationId: number) {
    return this.prisma.consultation.update({
      where: { id: consultationId },
      data: {
        status: 'IN_PROGRESS',
        startTime: new Date(),
      },
    });
  }

  async endConsultation(consultationId: number, notes?: string) {
    const consultation = await this.prisma.consultation.findUnique({
      where: { id: consultationId },
    });

    if (!consultation) {
      throw new Error('Ø§Ù„Ø§Ø³ØªØ´Ø§Ø±Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©');
    }

    const endTime = new Date();
    const duration = Math.floor((endTime.getTime() - consultation.startTime.getTime()) / (1000 * 60));

    return this.prisma.consultation.update({
      where: { id: consultationId },
      data: {
        status: 'COMPLETED',
        endTime,
        duration,
        notes,
      },
    });
  }

  async getConsultationMessages(consultationId: number) {
    return this.prisma.message.findMany({
      where: { consultationId },
      include: {
        sender: {
          include: { profile: true },
        },
      },
      orderBy: { createdAt: 'asc' },
    });
  }

  async sendMessage(consultationId: number, senderId: number, message: string, messageType: string = 'TEXT') {
    return this.prisma.message.create({
      data: {
        consultationId,
        senderId,
        message,
        messageType,
      },
      include: {
        sender: {
          include: { profile: true },
        },
      },
    });
  }

  async getConsultationHistory(patientId: number, doctorId?: number) {
    return this.prisma.consultation.findMany({
      where: {
        appointment: {
          patientId,
          ...(doctorId && { doctorId }),
        },
      },
      include: {
        appointment: {
          include: {
            patient: {
              include: { profile: true },
            },
            doctor: {
              include: { profile: true },
            },
          },
        },
        messages: {
          include: {
            sender: {
              include: { profile: true },
            },
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });
  }
}
```

#### **1.2 ÙˆØ­Ø¯Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„**
```typescript
// src/modules/messages/messages.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../database/prisma.service';
import { CreateMessageDto } from './dto/create-message.dto';

@Injectable()
export class MessagesService {
  constructor(private prisma: PrismaService) {}

  async create(createMessageDto: CreateMessageDto) {
    return this.prisma.message.create({
      data: createMessageDto,
      include: {
        sender: {
          include: { profile: true },
        },
        consultation: {
          include: {
            appointment: {
              include: {
                patient: {
                  include: { profile: true },
                },
                doctor: {
                  include: { profile: true },
                },
              },
            },
          },
        },
      },
    });
  }

  async getMessagesByConsultation(consultationId: number) {
    return this.prisma.message.findMany({
      where: { consultationId },
      include: {
        sender: {
          include: { profile: true },
        },
      },
      orderBy: { createdAt: 'asc' },
    });
  }

  async getUnreadMessages(userId: number) {
    return this.prisma.message.findMany({
      where: {
        consultation: {
          appointment: {
            OR: [
              { patientId: userId },
              { doctorId: userId },
            ],
          },
        },
        senderId: { not: userId },
        // Ø¥Ø¶Ø§ÙØ© Ù…Ù†Ø·Ù‚ Ù„Ù„Ø±Ø³Ø§Ø¦Ù„ ØºÙŠØ± Ø§Ù„Ù…Ù‚Ø±ÙˆØ¡Ø©
      },
      include: {
        sender: {
          include: { profile: true },
        },
        consultation: {
          include: {
            appointment: {
              include: {
                patient: {
                  include: { profile: true },
                },
                doctor: {
                  include: { profile: true },
                },
              },
            },
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async markAsRead(messageId: number) {
    // Ù…Ù†Ø·Ù‚ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ÙƒÙ…Ù‚Ø±ÙˆØ¡Ø©
    // ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ø¬Ø¯ÙˆÙ„ Ù…Ù†ÙØµÙ„ Ù„ØªØªØ¨Ø¹ Ø­Ø§Ù„Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©
    return { success: true };
  }
}
```

### **Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø«Ø§Ù†ÙŠ: ØªÙƒØ§Ù…Ù„ Agora Ù„Ù„ÙÙŠØ¯ÙŠÙˆ**

#### **2.1 Ø®Ø¯Ù…Ø© Agora**
```typescript
// src/modules/agora/agora.service.ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class AgoraService {
  constructor(private configService: ConfigService) {}

  async generateToken(channelName: string, uid: number, role: string = 'publisher') {
    const appId = this.configService.get('AGORA_APP_ID');
    const appCertificate = this.configService.get('AGORA_APP_CERTIFICATE');
    
    // Ø¥Ù†Ø´Ø§Ø¡ Agora token
    const token = this.createToken(appId, appCertificate, channelName, uid, role);
    
    return {
      appId,
      channel: channelName,
      token,
      uid,
    };
  }

  async generateChannelName(consultationId: number) {
    return `consultation_${consultationId}`;
  }

  async getRecordingCredentials(channelName: string) {
    // Ø¥Ø¹Ø¯Ø§Ø¯ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…ÙƒØ§Ù„Ù…Ø§Øª
    return {
      channel: channelName,
      recordingConfig: {
        maxIdleTime: 30,
        streamTypes: 2,
        audioProfile: 1,
        videoStreamType: 0,
        channelType: 0,
        subscribeVideoUids: [],
        subscribeAudioUids: [],
        subscribeUidGroup: 0,
      },
    };
  }

  private createToken(appId: string, appCertificate: string, channelName: string, uid: number, role: string) {
    // Ù…Ù†Ø·Ù‚ Ø¥Ù†Ø´Ø§Ø¡ Agora token
    // Ù‡Ø°Ø§ ÙŠØªØ·Ù„Ø¨ ØªØ«Ø¨ÙŠØª Agora SDK
    const agora = require('agora-access-token');
    
    const token = new agora.RtcTokenBuilder()
      .setAppId(appId)
      .setAppCertificate(appCertificate)
      .setChannelName(channelName)
      .setUid(uid)
      .setRole(role)
      .setPrivilegeExpiredTs(Math.floor(Date.now() / 1000) + 3600)
      .build();

    return token;
  }
}
```

#### **2.2 Agora Controller**
```typescript
// src/modules/agora/agora.controller.ts
import { Controller, Post, Body, UseGuards } from '@nestjs/common';
import { AgoraService } from './agora.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('agora')
@UseGuards(JwtAuthGuard)
export class AgoraController {
  constructor(private agoraService: AgoraService) {}

  @Post('token')
  async generateToken(@Body() body: { channelName: string; uid: number; role?: string }) {
    return this.agoraService.generateToken(body.channelName, body.uid, body.role);
  }

  @Post('channel')
  async createChannel(@Body() body: { consultationId: number }) {
    const channelName = await this.agoraService.generateChannelName(body.consultationId);
    return { channelName };
  }

  @Post('recording')
  async startRecording(@Body() body: { channelName: string }) {
    return this.agoraService.getRecordingCredentials(body.channelName);
  }
}
```

### **Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø«Ø§Ù„Ø«: WebSocket Gateways**

#### **3.1 Consultation Gateway**
```typescript
// src/common/gateways/consultation.gateway.ts
import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  MessageBody,
  ConnectedSocket,
  OnGatewayConnection,
  OnGatewayDisconnect,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from '../guards/jwt-auth.guard';

@WebSocketGateway({
  cors: {
    origin: '*',
  },
  namespace: '/consultation',
})
export class ConsultationGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  private connectedUsers = new Map<string, string>();

  handleConnection(client: Socket) {
    console.log(`Client connected: ${client.id}`);
  }

  handleDisconnect(client: Socket) {
    console.log(`Client disconnected: ${client.id}`);
    // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØµÙ„ÙŠÙ†
    for (const [userId, socketId] of this.connectedUsers.entries()) {
      if (socketId === client.id) {
        this.connectedUsers.delete(userId);
        break;
      }
    }
  }

  @SubscribeMessage('join-consultation')
  handleJoinConsultation(
    @MessageBody() data: { consultationId: number; userId: number },
    @ConnectedSocket() client: Socket,
  ) {
    const room = `consultation_${data.consultationId}`;
    client.join(room);
    this.connectedUsers.set(data.userId.toString(), client.id);
    
    // Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ† Ø§Ù„Ø¢Ø®Ø±ÙŠÙ†
    client.to(room).emit('user-joined', {
      userId: data.userId,
      timestamp: new Date(),
    });
  }

  @SubscribeMessage('leave-consultation')
  handleLeaveConsultation(
    @MessageBody() data: { consultationId: number; userId: number },
    @ConnectedSocket() client: Socket,
  ) {
    const room = `consultation_${data.consultationId}`;
    client.leave(room);
    this.connectedUsers.delete(data.userId.toString());
    
    // Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ† Ø§Ù„Ø¢Ø®Ø±ÙŠÙ†
    client.to(room).emit('user-left', {
      userId: data.userId,
      timestamp: new Date(),
    });
  }

  @SubscribeMessage('start-consultation')
  handleStartConsultation(
    @MessageBody() data: { consultationId: number },
    @ConnectedSocket() client: Socket,
  ) {
    const room = `consultation_${data.consultationId}`;
    this.server.to(room).emit('consultation-started', {
      consultationId: data.consultationId,
      timestamp: new Date(),
    });
  }

  @SubscribeMessage('end-consultation')
  handleEndConsultation(
    @MessageBody() data: { consultationId: number },
    @ConnectedSocket() client: Socket,
  ) {
    const room = `consultation_${data.consultationId}`;
    this.server.to(room).emit('consultation-ended', {
      consultationId: data.consultationId,
      timestamp: new Date(),
    });
  }

  // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
  sendNotificationToUser(userId: number, notification: any) {
    const socketId = this.connectedUsers.get(userId.toString());
    if (socketId) {
      this.server.to(socketId).emit('notification', notification);
    }
  }

  // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù„ØºØ±ÙØ© Ø§Ù„Ø§Ø³ØªØ´Ø§Ø±Ø©
  sendNotificationToConsultation(consultationId: number, notification: any) {
    const room = `consultation_${consultationId}`;
    this.server.to(room).emit('consultation-notification', notification);
  }
}
```

#### **3.2 Message Gateway**
```typescript
// src/common/gateways/message.gateway.ts
import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  MessageBody,
  ConnectedSocket,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';

@WebSocketGateway({
  cors: {
    origin: '*',
  },
  namespace: '/messages',
})
export class MessageGateway {
  @WebSocketServer()
  server: Server;

  @SubscribeMessage('send-message')
  handleSendMessage(
    @MessageBody() data: { consultationId: number; message: string; senderId: number },
    @ConnectedSocket() client: Socket,
  ) {
    const room = `consultation_${data.consultationId}`;
    
    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ† ÙÙŠ Ø§Ù„Ø§Ø³ØªØ´Ø§Ø±Ø©
    this.server.to(room).emit('new-message', {
      consultationId: data.consultationId,
      message: data.message,
      senderId: data.senderId,
      timestamp: new Date(),
    });
  }

  @SubscribeMessage('typing')
  handleTyping(
    @MessageBody() data: { consultationId: number; userId: number; isTyping: boolean },
    @ConnectedSocket() client: Socket,
  ) {
    const room = `consultation_${data.consultationId}`;
    client.to(room).emit('user-typing', {
      userId: data.userId,
      isTyping: data.isTyping,
      timestamp: new Date(),
    });
  }

  @SubscribeMessage('message-read')
  handleMessageRead(
    @MessageBody() data: { messageId: number; userId: number },
    @ConnectedSocket() client: Socket,
  ) {
    // Ù…Ù†Ø·Ù‚ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙƒÙ…Ù‚Ø±ÙˆØ¡Ø©
    this.server.emit('message-read-status', {
      messageId: data.messageId,
      userId: data.userId,
      timestamp: new Date(),
    });
  }
}
```

### **Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø±Ø§Ø¨Ø¹: Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª ÙˆØ§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª**

#### **4.1 ÙˆØ­Ø¯Ø© Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª**
```typescript
// src/modules/file-upload/file-upload.service.ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class FileUploadService {
  private s3Client: S3Client;

  constructor(private configService: ConfigService) {
    this.s3Client = new S3Client({
      region: this.configService.get('AWS_REGION'),
      credentials: {
        accessKeyId: this.configService.get('AWS_ACCESS_KEY_ID'),
        secretAccessKey: this.configService.get('AWS_SECRET_ACCESS_KEY'),
      },
    });
  }

  async uploadFile(file: Express.Multer.File, folder: string = 'consultations') {
    const fileExtension = file.originalname.split('.').pop();
    const fileName = `${folder}/${uuidv4()}.${fileExtension}`;

    const command = new PutObjectCommand({
      Bucket: this.configService.get('AWS_S3_BUCKET'),
      Key: fileName,
      Body: file.buffer,
      ContentType: file.mimetype,
    });

    await this.s3Client.send(command);

    return {
      fileName,
      url: `https://${this.configService.get('AWS_S3_BUCKET')}.s3.amazonaws.com/${fileName}`,
    };
  }

  async uploadMultipleFiles(files: Express.Multer.File[], folder: string = 'consultations') {
    const uploadPromises = files.map(file => this.uploadFile(file, folder));
    return Promise.all(uploadPromises);
  }

  async deleteFile(fileName: string) {
    const command = new DeleteObjectCommand({
      Bucket: this.configService.get('AWS_S3_BUCKET'),
      Key: fileName,
    });

    await this.s3Client.send(command);
    return { success: true };
  }
}
```

#### **4.2 ÙˆØ­Ø¯Ø© Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª**
```typescript
// src/modules/ratings/ratings.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../database/prisma.service';
import { CreateRatingDto } from './dto/create-rating.dto';

@Injectable()
export class RatingsService {
  constructor(private prisma: PrismaService) {}

  async create(createRatingDto: CreateRatingDto) {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ù…Ø³Ø¨Ù‚Ø§Ù‹
    const existingRating = await this.prisma.rating.findUnique({
      where: { appointmentId: createRatingDto.appointmentId },
    });

    if (existingRating) {
      throw new Error('ØªÙ… ØªÙ‚ÙŠÙŠÙ… Ù‡Ø°Ø§ Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹');
    }

    return this.prisma.rating.create({
      data: createRatingDto,
      include: {
        patient: {
          include: { profile: true },
        },
        doctor: {
          include: { profile: true },
        },
        appointment: true,
      },
    });
  }

  async getDoctorRatings(doctorId: number) {
    const ratings = await this.prisma.rating.findMany({
      where: { doctorId },
      include: {
        patient: {
          include: { profile: true },
        },
        appointment: true,
      },
      orderBy: { createdAt: 'desc' },
    });

    const averageRating = ratings.length > 0 
      ? ratings.reduce((sum, rating) => sum + rating.rating, 0) / ratings.length 
      : 0;

    return {
      ratings,
      averageRating: Math.round(averageRating * 10) / 10,
      totalRatings: ratings.length,
    };
  }

  async getPatientRatings(patientId: number) {
    return this.prisma.rating.findMany({
      where: { patientId },
      include: {
        doctor: {
          include: { profile: true },
        },
        appointment: true,
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async updateRating(ratingId: number, updateData: any) {
    return this.prisma.rating.update({
      where: { id: ratingId },
      data: updateData,
      include: {
        patient: {
          include: { profile: true },
        },
        doctor: {
          include: { profile: true },
        },
        appointment: true,
      },
    });
  }

  async deleteRating(ratingId: number) {
    return this.prisma.rating.delete({
      where: { id: ratingId },
    });
  }
}
```

---

## ğŸ”§ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©

### **Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø© Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ©**
```env
# Agora
AGORA_APP_ID=your_agora_app_id
AGORA_APP_CERTIFICATE=your_agora_app_certificate

# AWS S3
AWS_REGION=us-east-1
AWS_ACCESS_KEY_ID=your_aws_access_key_id
AWS_SECRET_ACCESS_KEY=your_aws_secret_access_key
AWS_S3_BUCKET=your_s3_bucket_name

# File Upload
MAX_FILE_SIZE=10485760  # 10MB
ALLOWED_FILE_TYPES=image/jpeg,image/png,image/gif,application/pdf,text/plain
```

---

## ğŸ“Š Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ù†Ø¬Ø§Ø­

### **Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**
1. âœ… Ù†Ø¸Ø§Ù… Ø§Ø³ØªØ´Ø§Ø±Ø§Øª Ø§ÙØªØ±Ø§Ø¶ÙŠØ© ÙŠØ¹Ù…Ù„
2. âœ… Ù…ÙƒØ§Ù„Ù…Ø§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ØªØ¹Ù…Ù„ Ù…Ø¹ Agora
3. âœ… Ù†Ø¸Ø§Ù… Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø© ÙŠØ¹Ù…Ù„
4. âœ… Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª ÙŠØ¹Ù…Ù„
5. âœ… Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª ÙŠØ¹Ù…Ù„
6. âœ… WebSocket Gateways ØªØ¹Ù…Ù„

### **Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**
- [ ] Ø¨Ø¯Ø¡ Ø§Ø³ØªØ´Ø§Ø±Ø© Ø¬Ø¯ÙŠØ¯Ø©
- [ ] Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„ ÙÙŠ Ø§Ù„Ø§Ø³ØªØ´Ø§Ø±Ø©
- [ ] Ù…ÙƒØ§Ù„Ù…Ø© ÙÙŠØ¯ÙŠÙˆ
- [ ] Ø±ÙØ¹ Ù…Ù„ÙØ§Øª
- [ ] ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø·Ø¨ÙŠØ¨
- [ ] Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù…Ø¨Ø§Ø´Ø±Ø©

---

## ğŸš€ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©

Ø¨Ø¹Ø¯ Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø©ØŒ Ø³ØªÙƒÙˆÙ† Ø¬Ø§Ù‡Ø²Ø§Ù‹ Ù„Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰:
- **Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø±Ø§Ø¨Ø¹Ø©:** Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª ÙˆØ§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
- **Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø®Ø§Ù…Ø³Ø©:** Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª ÙˆØ§Ù„ØªÙ‚Ø§Ø±ÙŠØ±
- **Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø³Ø§Ø¯Ø³Ø©:** Ø§Ù„Ù†Ø´Ø± ÙˆØ§Ù„Ø¥Ù†ØªØ§Ø¬

---

*Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø© ØªØ¶ÙŠÙ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù„Ù†Ø¸Ø§Ù… Ù…Ø¹ Ø§Ù„Ø§Ø³ØªØ´Ø§Ø±Ø§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©*
